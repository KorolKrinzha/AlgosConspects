# Сортировки

## Сортировка пузырьком

Сортировка пузырьком (англ. bubble sort) — алгоритм сортировки, в котором сравниваются пары соседних элементов.
Если они стоят в неправильном порядке, то производится их обмен.

Этот алгоритм называется сортировкой пузырьком,
потому что маленькие элементы постепенно «всплывают» до нужной позиции, как пузырьки в воде.

```java
public class BubbleSort {
    public static void main(String[] args) {
        int[] array = {1, 5, 4, 2, 8, 9, 7, 6, 3, 0};
        bubbleSort(array);
        System.out.println(Arrays.toString(array));
    }

    public static void bubbleSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
}
```

### Пример работы алгоритма:

1. [4,1,6,9,2]
2. [1,4,6,2,9]
3. [1,4,2,6,9]
4. [1,2,4,6,9] - массив отсортирован

Сложность алгоритма: O(n^2) (n раз делаем n перестановок)

Условие Айверсона-Тьюринга гласит, что если в процессе сортировки не было выполнено ни одной перестановки, то массив уже отсортирован.

Это условие позволяет улучшить эффективность алгоритма. Он позволяет прекратить работу, когда алгоритм уже отсортирован.

То есть сортировка может быть выполнена быстрее, чем O(n^2).

```java
public class BubbleSort {
    public static void main(String[] args) {
        int[] array = {1, 5, 4, 2, 8, 9, 7, 6, 3, 0};
        bubbleSort(array);
        System.out.println(Arrays.toString(array));
    }

    public static void bubbleSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            boolean swap_flag = false;
            for (int j = 0; j < array.length - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    swap_flag = true;
                }
            }
            if (not swap_flag) {
                break;
            }
        }
    }
}
```

## Сортировка выбором

1. Находим наименьший элемент в массиве. Ставим его на первое место.
2. Находим второй наименьший элемент в массиве. Ставим его на второе место.
3. Повторяем, пока не будет достигнут конец массива.

### Пример работы алгоритма:

0. Имеется один массив, два массива: отсортированный и неотсортированный.
1. [3,2,4,8,6,12] - неотсортированный [] - отсортированный
2. Берем первый элемент массива и считаем его минимальным. [3,2,4,8,6,12] - неотсортированный [3] - отсортированный
3. Сравниваем 3 с 2, 4, 8, 6, 12. Минимальный элемент - 2. [3,2,4,8,6,12] - неотсортированный [2,3] - отсортированный
4. Сравниваем 3 с 4, 8, 6, 12. Минимальный элемент - 3. [3,2,4,8,6,12] - неотсортированный [2,3,4] - отсортированный
5. Сравниваем 8 с 6, 12. Минимальный элемент - 6. [3,2,4,8,6,12] - неотсортированный [2,3,4,6,8] - отсортированный
6. Сравниваем 12 с 12. Минимальный элемент - 12. [3,2,4,8,6,12] - неотсортированный [2,3,4,6,8,12] - отсортированный
7. Массив отсортирован.

```java
public class SelectionSort {
    public static void main(String[] args) {
        int[] array = {1, 5, 4, 2, 8, 9, 7, 6, 3, 0};
        selectionSort(array);
        System.out.println(Arrays.toString(array));
    }

    public static void selectionSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            int min = array[i]; // наименьший элемент
            int minId = i; // индекс наименьшего элемента
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < min) {
                    // если нашли элемент меньше, чем на текущей позиции
                    // запоминаем его
                    min = array[j];
                    minId = j;
                }
            }
            // меняем местами наименьший элемент и первый элемент
            int temp = array[i];
            array[i] = min;
            array[minId] = temp;
        }
    }
}
```

Сложность алгоритма: O(n^2)

## Сортировка вставками

0. Разбиваем массив на две части: отсортированную и неотсортированную.
1. Начинаем с первого элемента массива и считаем его отсортированным.
   Он будет в первой части
2. Сравниваем следующий элемент с предыдущим и меняем их местами, если они не отсортированы.

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key_item = arr[i]
        j = i - 1
        while j >=0 and key_item < arr[j] :
                arr[j + 1] = arr[j]
                j -= 1
        arr[j + 1] = key_item
    return arr

arr = [5, 6, 3, 2, 8, 7, 2, 4]
sorted_arr = insertion_sort(arr)
print(sorted_arr)

```

### Пример работы алгоритма:

Разберем по итерациям: 0. [5,6,3,2,8,7,2,4] - изначальный массив

1. [5,6,3,2,8,7,2,4] - первый элемент массива - отсортированный.

```python
i = 1
key_item = arr[1] = 6
j = 1 - 1 = 0
```

Итерация while не проходит, так как 6 > 5

2. [5,6,3,2,8,7,2,4]

```python
i = 2
key_item = arr[2] = 3
j = 2 - 1 = 1
# входим в while
arr[j + 1] = arr[j] = 6
arr[j] = 3
j = j - 1 = 0
```

While заканчивается с массивом [5, 3, 6, 2, 8, 7, 2, 4]. Обновляем и получаем [3, 5, 6, 2, 8, 7, 2, 4]

3. [3,5,6,2,8,7,2,4]

```python
i = 3
key_item = arr[3] = 2
j = 3 - 1 = 2
# входим в while
arr[j + 1] = arr[j] = 6
arr[j] = 2
j = j - 1 = 1
arr = [3, 5, 2, 6, 8, 7, 2, 4]
```

4. [2,3,5,6,8,7,2,4]
   ...и так далее

## Сортировка подсчетом

0. Создаем нулевой массив, в котором будем хранить количество вхождений каждого элемента.
   Это будет массивом подсчетов.
1. Проходим по массиву и считаем количество вхождений каждого элемента.
2. Записываем количество вхождений в нулевой массив.
3. Создаем ненулевой массив, в котором будем хранить отсортированный массив.
4. Проходим по заполненному массиву подсчетов:
   если в нулевом массиве на позиции i есть число,
   то записываем его в ненулевой массив столько раз, сколько оно там есть.

В чем проблема: приведем пример [1, 2, 10001]

Мы создаем массив подсчетов размером 10001.
Но будут заполнены только 3 элемента, а остальная память будет зря расходоваться.

Как улучшить алгоритм: вместо массива подсчетов создаем map (словарь).
Ключ - элемент массива, значение - количество вхождений.

## Radix sort

Поразрядная сортировка. Работает только с числами и строками.

Это эффективный алгоритм для сортировки большого количества целых чисел.

1. Определяем количество цифр в самом большом числе в массиве.
   Это количество проходов алгоритма.
2. Начиная с наименьшей значащей цифры, отсортируем элементы массива по текущей цифре.
3. Перейдем к следующей значащей цифре и повторите шаг 2.
4. Повторяем, пока не отсортируем все элементы.

### Пример работы алгоритма:

0. Дано [432,76,148,18,9]
1. Заведем ArrayList ArrayListов.
   Сортируем по единицам:

- 0:
- 1:
- 2: 432
- 3:
- 4:
- 5:
- 6: 76
- 7:
- 8: 148 18
- 9: 9

2. [432, 76, 148, 18, 9]
3. Сортируем по десяткам:

- 0: 9
- 1: 18
- 2:
- 3: 432
- 4: 148
- 5:
- 6:
- 7: 76
- 8:
- 9:

4. [9, 18, 432, 148, 76]. Видим, что массив уже практически отсортирован. Остался только 1 проход.
5. Сортируем по сотням:
   0: 9, 18, 76
   1: 148
   ...

6. [9,18,76,148,432]
7. Массив отсортирован

Сложность алгоритма: O(k\*(n+p)), где n - количество элементов,
k - logpnmax, p - количество разрядов (для десятичных чисел это 10).

## Сортировка кучей

Но сначала...

## Куча

Куча - это дерево

- бинарное: каждый узел имеет не более двух потомков
- плотное: все узлы заполнены, кроме последнего уровня
- дерево хранит сравнимые элементы (например, числа)
- каждый узел больше или меньше (по выбору) своих потомков

Реализация кучи: массив.

### Как выглядит куча в виде дерева и массива

```
     3
    / \
   4   6
  / \ /  \
 5  10 15 8

```

Расставим индексы

```
     0
    / \
   1   2
  / \ /  \
 3  4 5  6

```

```
[3,4,6,5,10,15,8]
```

### Операции над кучей

**SiftUp** - поднять элемент вверх по куче,
пока он не станет корнем или не станет больше своего родителя.

Сложность алгоритма: O(log2n)

В куче можно удалять только корень. Иначе нарушится структура кучи.

Операция **SiftDown** - просеивание элемента вниз по куче

Где использовать кучу:

- priority queue
- сортировка кучей

### Как строить из рандомного массива кучу

1. Начинаем с середины массива, так как все узлы после середины являются листьями.
   Листья по умолчанию удовлетворяют свойству кучи.
2. Для каждого рассматриваемого узла сравним его значение со значениями его дочерних узлов.
   Поменяем местами узел с большим дочерним узлом, если это необходимо для сохранения свойства максимальной/минимальной кучи.
3. Двигаемся вверх по дереву
   и повторяем шаг 2 для каждого узла, пока весь массив не будет удовлетворять свойству кучности.

Сложность: O(n)

Пример: 0. Дан массив [13, 11, 7, 5, 6, 12]. Построим из него кучу с максимальной верхушкой (max в индексе 0)

1. 6//2 - 1 = 2. Это индекс середины массива.
2. Сравниваем 7 с детьми. 12 больше 7, [13, 11, 12, 5, 6, 7]
3. Сравниваем 11 с детьми. Меняем 12 и 11 местами, так как 12 больше [13, 12, 11, 5, 6, 7]
4. Сравниваем 13 с детьми. 13 больше обоих двух детей, поэтому перестановок нет [13, 12, 11, 5, 6, 7]

## Сортировка кучей

0. Необходимо отсортировать массив A размером n
1. Построим кучу из массива A за O(n)
2. Максимальный элемент находится в корне кучи.
3. "Выкидываем" корень в конец, как бы "в сторонку".
4. Уменьшаем размер кучи на 1.
5. Просеиваем корень кучи вниз, чтобы восстановить свойство кучи.
6. Куча имеет размер n-1.
7. Повторяем шаги 2-6, пока куча не станет пустой.
8. Всего будет сделано n-1 операций SiftDown, каждая операция SiftDown имеет сложность O(log2n)

Сложность алгоритма: O(nlog2n)

Недостаток:

- неустойчивая сортировка. Например, если в массиве есть два одинаковых элемента, то после сортировки они могут поменяться местами.
- на почти отсортированных массивах работает столько же долго,
  сколько на неотсортированном (для этого лучше пузырек).

## Быстрая сортировка

### Сложность алгоритма:

- В среднем случае: O(nlog2n)
- В худшем случае: O(n^2)

0. Дан массив [5, 6, 3, 2, 8, 7, 2, 4]:
1. Выберем опорный элемент (pivot) - 5
2. Разделим массив на две части: элементы меньше 5 и элементы больше 5
   [3, 2, 4, 2] и [6, 8, 7]
3. Рекурсивно сортируем два подмассива, повторяя шаги 1 и 2.

Пример:

1. [1,3,2,4,8,1,2]
2. pivot = 4
3. [1,3,2,4,2,1][8]
4. pivot = 3
5. [1,3,2,2,1][4][8]
6. pivot = 2
7. [1,2,2,1][3][4][8]
8. pivot = 1
9. [1,1][2][2][3][4][8]
10. [1,1,2,2,3,4,8]
11. Массив отсортирован

# Задачи на сортировку

## Задача 1.

Дана строка s и целое число k (окно для кидания элементов в конец.
Здесь два первые могут быть отправлены в конец).

```
s = Dadb
===> s = Adbd
==> s = dBda
==> s = ddab
```

Лексикографический порядок: a>b, b>c и т.д.

Что это: Сортировка пузырьком на циклическом сдвиге.
