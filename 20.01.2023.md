# Бинарный поиск

## Есть массив из n чисел, найти в нем x

Как найти:

1. Пройти for
2. Бинпоиск

Рассмотрим варианты

1. Пройти for.

Почему это плохо? Занимает слишком много времени Сложность O(n). Растет линейно.

2. Бинарный поиск упрощает поиск в отсортированном массиве.

Как "прийти" к бинпоиску

1. Два указателя на начало и конец массива L и R
   L - левая граница, на один элемент левее начала массива
   R - правая граница, на один элемент правее конца массива
2. Средний элемент mid = (L+R)/2
3. Если mid == x, то мы нашли x
4. Если x лежит слева от mid, то сдвигаем правую границу R = mid - 1
5. Если x лежит справа от mid, то сдвигаем левую границу L = mid + 1

## Задача №1

Массив по возрастанию содержит 0 и 1. Где находится первый 1?

```java
int L = -1
int R = N
while (R-L>1){
    int mid  = (L+R)/2
    if (a[mid] == x){
        R = mid
    }
    L = mid

}
```

## Задача №2

Массив по возрастанию. Найти 34.

```java
int L = -1
int R = N
while (R-L>1){
    int mid = (L+R)/2
    if (Arr[mid]>= 34){
        R = mid;
    }
    else{
        L = mid;
    }
}

if (R!= N && Arr[R] == 34){
    System.out.println(R)
}
else{
    System.out.println(-1)
}

```

## Задача №3

Найти самое правое вхождение числа 34 в массив по возрастанию.
Изменить больше или равно на больше

```java
int L = -1
int R = N
while (R-L>1){
    int mid = (L+R)/2
    if (Arr[mid]> 34){
        R = mid;
    }
    else{
        L = mid;
    }
}

if (L!= -1 && Arr[L] == 34){
    System.out.println(L)
}
else{
    System.out.println(-1)
}
```

Бинарный поиск делится на два типа: **левосторонний** (ответ в L) и **правосторонний** (ответ в R)

## Бинарный поиск по ответу

Задача про листы и копиры. Называется "Дипломы"

Пример: N = 4 копии Принтер X печатает за 3 секунды, а принтер Y за 2 секунды.

Найти минимальное время, за которое можно распечатать все дипломы.

Ответ: первая копирка за 2 секунды. Потом берм копии и кладем на второй принтер, задействуем два принтера одновременного.

А что делать с большими числами?

Сколько за N секунд успеем сделать копий?
T всего
X
copies = 1+ (T-X)/X + (T - X)/Y

А теперь бинарный поиск по ответу

Бинарный поиск применим для поиска любой монотонной функции, непрерывной на отрезке [L,R]
