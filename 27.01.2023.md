# Базовые структуры данных

Стек, очередь, дек, куча

## Стек

Аналогия со стаканами. Кладем в нем диски с одинаковым диаметром.
Последний, который положили, первый, который достали.

FILO - First In Last Out

### Операции
    
      * `push` - положить элемент в стек
      * `pop` - достать элемент из стека
      * `top`/`front` - посмотреть элемент в вершине стека
      * `size` - размер стека
      * `empty` (дополнительно) - проверить, пустой ли стек

### Реализация

Стек реализован на массиве. 

Рассмотрим случай работы стека:

    * До начала действий: пустой массив из двух элементов
    * Push 1: [1, 0] Size: 1 Capacity: 2
    * Push 2: [1, 2] Size: 2 Capacity: 2
    * Push 3. 
    Создаем новый массив размера в два раза большего предыдущего. 
    Поочередно копируем элементы старого массива в новый: [1, 2, 3, 0] Size: 3 Capacity: 4
    * Pop: [1, 2, 0, 0] Size: 2 Capacity: 4
    * Front: 2

**Динамические массивы расширяются в два раза!**         

### Временная сложность

    * push - O(1)
    * pop - O(1)
    * top - O(1)
    * size - O(1) (*Размер стека поддерживается с помощью переменной, 
    которая увеличивается при добавлении нового элемента и уменьшается при удалении элемента. 
    Для извлечения этой переменной требуется только одна операция*)

## Очередь

Аналогия с очередью в кассе. Первый, кто пришел, первый, кто ушел.

FIFO - First In First Out

### Операции
    
      * `push` - положить элемент в очередь
      * `pop` - достать первый элемент очереди
      * `front` - посмотреть элемент в начале очереди
      * `size` - размер очереди

### Реализация

Очередь реализована на массиве.

Рассмотрим случай работы очереди:

    * До начала действий: пустой массив из двух элементов
    * Push 1: [0, 1] Size: 1 Capacity: 2
    * Push 2: [2, 1] Size: 2 Capacity: 2
    * Push 3: [0,3,2,1] Size: 3 Capacity: 4
    * Pop: [0,3,2,0] Size: 2 Capacity: 4
    * Front: 2

### Зацикленная очередь

Как решить проблему с избыточным расширением массива?

Пусть больше пяти элементов очереди лежать не может. 

Тогда выделяем массив с фиксированным массивом размера 5.

Рассмотрим случай работы:

* Сначала было 0,1,2,3,4 - [0,0,1,6,9], cursor = 2, l = 4
* Push 10: [10,0,1,6,9], l переезжает на 0, cursor остается на 2
* Индексы зацикливаются

## Дек aka deque (двусторонняя очередь)

Deque = double-ended queue

### Операции

    * `push_front` - положить элемент в начало очереди
    * `push_back` - положить элемент в конец очереди
    * `pop_front` - достать первый элемент очереди
    * `pop_back` - достать последний элемент очереди
    * `front` - посмотреть элемент в начале очереди
    * `back` - посмотреть элемент в конце очереди
    * `size` - размер очереди

## Двоичная куча aka пирамида

Двоичная куча - это двоичное дерево, у каждой вершины максимум два потомка


Куче соответствует массив: [9,7,8,1,2,3,4] с индексами 0,1,2,3,4,5,6

i -> 2i+1, 2i+2 - индексы потомков

У дерева есть слои 0,1,2,3,... Каждый слой - это уровень

## Необходимые свойства двоичной кучи

* На каждом слое, кроме последнего, должно быть 2^i вершин (у вершины ровно два потомка)
* У потомков вершины должно быть значение не больше, чем у родительской вершины

Следствие: **корень - максимальный элемент**

## Операции

    * `push` - положить элемент в кучу
    * `get_max` (`pop`) - достать максимальный элемент из кучи
    * `size` - размер кучи
    * `max` - максимальный элемент в куче

Рассмотрим get_max на примере кучи [9,7,8,1,2,3,4]. Достали 9, теперь [0,8,7,4,1,2,3]. 
Далее переставляем элементы, чтобы свойство корня кучи не нарушалось: [8,7,4,1,2,3,0].
Такая операция называется **просеиванием** (sift-down).

Time complexity: O(log n)

Рассмотрим push на примере кучи [8,7,4,1,2,3,0]. 
Добавили 10 в самый нижний элемент, теперь [8,7,4,1,2,3,0,10].
Пока куча нарушена, необходимо поменять родительский и дочерний элемент. Так мы будем **просеивать вверх** элементы, пока не будет достигнуто свойство корня кучи (операция sift up).
Получилась куча [10,8,4,3,2,1,7].

Time complexity: O(log n)

Почему log n? log2n - высота дерева (количество слоев), где n - количество элементов в куче.

## Временная сложность

    * `push` - O(log n)
    * `get_max` - O(log n)
    * `size` - O(1)
    * `max` - O(1)
