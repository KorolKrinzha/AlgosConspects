## Алгоритм Дейкстры

## Взвешенный граф

Хранение взвешннного графа происходит с помощью списка смежности. Вес ребра между вершинами обозначается целым числом, а отсутствие ребра либо нулем, либо с помощью специального значения

|       | **a** | **b** | **c** |
| ----- | ----- | ----- | ----- |
| **a** | 0     | 3     | 5     |
| **b** | 3     | 0     | 8     |
| **c** | 5     | 8     | 0     |

### Хранение в джаве

Граф - словарь, в котором ключи - вершины, значения - список ребер, которые исходят из этой вершины

```java
Map<Integer, List<Edge>> graph = new HashMap<Integer, List<Edge>>();
```

Ребро, исходящее из вершины

```java
class Edge{
    public int neighbor; // вершина-сосед
    public int weight; // вес ребра
}
```

Пример графа:

```java
graph = {
    1: [new Edge(2,7), new Edge(3,1)],
    2: [new Edge(1,7), new Edge(4,3)],
    3: [new Edge(4,2), new Edge(6,1), new Edge(1,1)],
    4: [new Edge(2,3), new Edge(5,4), new Edge(3,2)],
    5: [new Edge(4,4), new Edge(7,5), new Edge(8,20)],
    6: [new Edge(3,1), new Edge(7,13), new Edge(9,9)],
    7: [new Edge(6,13), new Edge(9,1), new Edge(8,3), new Edge(5,5)],
    8: [new Edge(5,10), new Edge(7,3), new Edge(9,6)],
    9: [new Edge(6,9), new Edge(7,1), new Edge(8,6)]
}

```

Отобразим получившейся граф с помощью матрицы смежности

|     | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 7   | 1   | 0   | 0   | 0   | 0   | 0   | 0   |
| 2   | 7   | 0   | 0   | 3   | 0   | 0   | 0   | 0   | 0   |
| 3   | 1   | 0   | 0   | 2   | 0   | 1   | 0   | 0   | 0   |
| 4   | 0   | 3   | 2   | 0   | 4   | 0   | 0   | 0   | 0   |
| 5   | 0   | 0   | 0   | 4   | 0   | 0   | 5   | 20  | 0   |
| 6   | 0   | 0   | 1   | 0   | 0   | 0   | 13  | 0   | 9   |
| 7   | 0   | 0   | 0   | 0   | 5   | 13  | 0   | 3   | 1   |
| 8   | 0   | 0   | 0   | 0   | 20  | 0   | 3   | 0   | 6   |
| 9   | 0   | 0   | 0   | 0   | 0   | 9   | 1   | 6   | 0   |

## Алгоритм Дейкстры с помощью взвешенного графа

Алгоритм Дейкстры использует взвешенный граф для поиска кратчайшего пути между двумя вершинами.

## Реализация на java

```java
import java.util.*;

public class DijkstraAlgorithm {
    public static void main(String[] args) {
        Map<Integer, List<Edge>> graph = new HashMap<Integer, List<Edge>>();

        // добавление вершин и ребер в граф
        // ...

        int startVertex = 1; // начальная вершина для поиска кратчайшего пути
        int[] distances = dijkstra(graph, startVertex);
        System.out.println(Arrays.toString(distances)); // печать массива кратчайших расстояний от startVertex до остальных вершин
    }

    public static int[] dijkstra(Map<Integer, List<Edge>> graph, int startVertex) {
        int n = graph.size();
        int[] distances = new int[n+1];
        Arrays.fill(distances, Integer.MAX_VALUE); // по аналогии с бесконечность, бесконечность, бесконечность...
        distances[startVertex] = 0; // мы уже там, где начальная вершина. Расстояние 1
        PriorityQueue<Node> pq = new PriorityQueue<Node>(n, new Node()); // хранения вершин графа, которые еще не были посещены.

        // добавляем начальную вершину в очередь - начинаем с нее
        pq.add(new Node(startVertex, 0));

        // обходим граф
        while (!pq.isEmpty()) {
            // берем наименьшую вершину
            Node currentNode = pq.poll();
            int currentVertex = currentNode.vertex;
            int currentDistance = currentNode.distance;

            // проверяем все смежные вершины
            List<Edge> edges = graph.get(currentVertex);
            if (edges != null) {
                for (Edge edge : edges) {
                    int neighbor = edge.neighbor;
                    int weight = edge.weight;
                    int distance = currentDistance + weight;

                    if (distance < distances[neighbor]) {
                        // если найден более короткий путь, обновляем кратчайшее расстояние и добавляем вершину в очередь
                        distances[neighbor] = distance;
                        pq.add(new Node(neighbor, distance));
                    }
                }
            }
        }

        return distances;
    }

    // имплементируем компаратор, чтобы можно было сравнивать node
    // и распределять их по приоритету
    static class Node implements Comparator<Node> {
        public int vertex;
        public int distance;

        public Node() {}

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        // Метод статического класса. Сравнивает две вершины. Возвращает < > или =
        public int compare(Node node1, Node node2) {
            if (node1.distance < node2.distance) {
                return -1;
            }
            if (node1.distance > node2.distance) {
                return 1;
            }
            return 0;
        }
    }


    // реализация ребра, которую мы обсудили ранее
    static class Edge {
        public int neighbor;
        public int weight;

        public Edge() {}

        public Edge(int neighbor, int weight) {
            this.neighbor = neighbor;
            this.weight = weight;
        }
    }
}
```

PriorityQueue - это класс в Java, который реализует структуру данных "очередь с приоритетом". Он работает так же, как обычная очередь, но элементы в ней упорядочены по определенному признаку при добавлении в очередь, и элементы извлекаются в порядке их приоритета, а не в порядке добавления. По сути, это "минимальная куча"

В нашем алгоритме PriorityQueue используется для хранения вершин графа, которые еще не были посещены, но имеют кратчайшее расстояние от начальной вершины. В начале кучи стоят вершины с наименьшим расстоянием.

## Временная сложность

Временная сложность составляет O(E\*log(V)), где E - количество ребер в графе, а V - количество вершин.

Это происходит из-за использования приоритетной очереди (Priority Queue) для хранения расстояний до вершин. Каждый раз, когда мы извлекаем минимальный элемент из приоритетной очереди, мы выполняем операцию удаления из кучи, которая имеет временную сложность O(log V).
Мы делаем это для каждой вершины в графе, то есть V раз (V\*log(V)).

Также мы тратим время на работу с ребрами. Каждое ребро обрабатывается только один раз, и для каждого ребра мы выполняем следующие действия:

- Если текущее расстояние до вершины, которую мы можем достичь через это ребро, меньше, чем сохраненное ранее расстояние, мы обновляем расстояние до этой вершины и добавляем ее в очередь с приоритетом для дальнейшей обработки. Добавление элемента в кучу занимает O(log V) времени.
- В противном случае мы игнорируем это ребро и переходим к следующему.

Таким образом, общая временная сложность алгоритма Дейкстры составляет
O(Vlog V + Elog V), что упрощается до O(E\*log V) в том случае, если граф связный.

Почему работает это упрощение? Здесь можно увидеть, что выражение O(Vlog V) не так существенно, как O(Elog V), потому что в худшем случае количество ребер E может быть гораздо больше, чем количество вершин V. Поэтому можно просто отбросить O(Vlog V) и оставить только O(Elog V), и получить временную сложность O(E\*log V).

## Дополнительная память

Затраты памяти алгоритма Дейкстры зависят от способа хранения графа. В нашем случае, мы используем список смежности, который требует O(V+E) памяти для хранения графа. Для хранения расстояний от исходной вершины до каждой другой вершины мы используем массив размера V, что также требует O(V) памяти. Кроме того, мы используем приоритетную очередь, которая в нашем случае использует кучу (heap), и требует O(V) памяти для хранения вершин, которые еще не были обработаны.

Таким образом, общие затраты памяти алгоритма Дейкстры с использованием списка смежности и кучи составляют O(V+E).
