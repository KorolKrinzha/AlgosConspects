Алгоритм Флойда-Уоршелла (или FW алгоритм) используется для нахождения кратчайшего пути взвешенного графа с положительными или отрицательными весами ребер, не имеющего циклов отрицательного веса.

## Принцип работы

Алгоритм работает в несколько этапов и основан на идее **динамического программирования**. На каждом шаге FW алгоритма рассматриваются все пары вершин и их расстояния между собой. На первом шаге (k=0) исходное расстояние между вершинами берется из **матрицы смежности**. На каждом следующем шаге (k=1,2,..n) используется ранее построенная матрица расстояний. Если есть путь между вершинами i и j, проходящий через вершину k, то расстояние между i и j можно уменьшить, заменив имеющееся расстояние между i и j на сумму расстояний между i и k и между k и j. Таким образом, на каждом шаге постепенно уточняется расстояние между каждой парой вершин.

Когда FW алгоритм завершается, матрица расстояний содержит кратчайшие расстояния между всеми парами вершин. Однако, если граф содержит цикл отрицательного веса, то алгоритм не сможет найти оптимальное решение.

## Реализация на java

```java
import java.util.Arrays;
public class Main {

    public static void main(String[] args) {

        // граф реализован через матрицу смежностей
        int[][] graph = {{0, 5, Integer.MAX_VALUE, 10},
                {Integer.MAX_VALUE, 0, 3, Integer.MAX_VALUE},
                {Integer.MAX_VALUE, Integer.MAX_VALUE, 0, 1},
                {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, 0}};

        FloydWarshallAlgorithm algorithm = new FloydWarshallAlgorithm();
        algorithm.floydWarshall(graph);

    }
}




class FloydWarshallAlgorithm {

    public void floydWarshall(int[][] graph) {
        int n = graph.length;

        // создаем матрицу расстояний и заполняем ее бесконечностями
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }

        // заполняем матрицу расстояний из графа
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = graph[i][j];
            }
        }

        // находим кратчайший путь между каждой парой вершин через промежуточную вершину
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE
                            && dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }

        // выводим матрицу расстояний
        printSolution(dist);
    }

    // метод для вывода матрицы расстояний
    public void printSolution(int[][] dist) {
        int n = dist.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][j] == Integer.MAX_VALUE) {
                    System.out.print("! ");
                } else {
                    System.out.print(dist[i][j] + " ");
                }
            }
            System.out.println();
        }
    }


}
```

### Про поиск кратчайшего пути и тройной цикл

Тройной цикл позволяет обойти все вершины графа и перебрать все возможные пути от каждой вершины до каждой вершины

```java
for (int k = 0; k < n; k++) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // код
        }
    }
}
```

На первой итерации (k=0), мы перебираем все возможные пары вершин i и j, и обновляем информацию о длине пути от i до j, если существует путь от i до j через вершину 0.

На второй итерации (k=1), мы перебираем все возможные пары вершин i и j, и обновляем информацию о длине пути от i до j, если существует путь от i до j через вершину 0 или 1.

На k-й итерации (k>1), мы перебираем все возможные пары вершин i и j, и обновляем информацию о длине пути от i до j, если существует путь от i до j через любую из вершин от 0 до k-1.

Таким образом, на каждой итерации мы рассматриваем все возможные пути от i до j через вершину k, и выбираем самый короткий из них, чтобы обновить информацию о длине пути от i до j. В результате тройного цикла, после k=n-1, мы получим матрицу расстояний между всеми парами вершин графа.

### Проверка на наличие меньшего пути

Эта строка кода проверяет, может ли путь от вершины i до вершины j быть улучшен при проходе через вершину k.

```java
if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE
                            && dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
```

Здесь dist[i][k] - это расстояние от вершины i до вершины k, dist[k][j] - это расстояние от вершины k до вершины j.

dist[i][j] хранит текущее расстояние между вершинами i и j.

Если расстояние между i и k, и между k и j не равно бесконечности, то значит есть путь от i до k и от k до j. Тогда мы можем проверить, улучшит ли добавление вершины k текущий путь.

Если расстояние от i до k, плюс расстояние от k до j меньше текущего расстояния между i и j, то мы можем обновить dist[i][j] с новым, более коротким путем через вершину k.

Это происходит в том случае, если нашелся новый более короткий путь, который проходит через вершину k. Если не нашлось пути через k, то значение dist[i][j] не изменится.

## Временная сложность

O(V^3), где V - количество вершин в графе

## Дополнительная память

O(V^2), так как есть дополнительная матрица, где мы измеряем веса
