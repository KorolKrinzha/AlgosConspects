## 1. Статический массив. Динамический массив, среднее время добавления элемента.

### Статический массив

**Определение** Это структура данных, которая хранит элементы
одного типа в последовательности _с фиксированным размером_
Каждый элемент массива имеет уникальный индекс (начиная с 0) и хранит значение заданного типа.

**Создание массива** Для создания статического массива необходимо указать его размер,
который определяется на этапе компиляции программы.
Размер статического массива не может быть изменен в процессе выполнения.

Для создания статического массива в Java необходимо указать его тип, имя и размер

```java
int[] arr = new int[10]; // создание массива на 10 элементов типа int
```

**Работа со статическим массивом** Для доступа к элементам массива используется индекс, который указывает на позицию элемента в массиве. Индексы в Java начинаются с нуля.

```java
// Работаем с уже созданным массивом
arr[0] = 1; // назначили первый элемент массива
arr[1] = 2; // назначили второй элемент массива
arr[0] = 10; // переписали первый элемент массива
```

**Операции с массивами** Создание, удаление, модификация (добавление/удаление/переписывание) элементов, итерация по элементам, сортировка, копирование, поиск элемента

### Динамический массив

**Чем отличается от статического** Размер массива может меняться по ходе своей работы (то есть динамически)

**Реализация** В языке Java динамический массив представлен классом ArrayList

Как работает ArrayList под капотом?

- При создании создается массив фиксированного размера
- При добавлении нового элемента проверяем, заполнен ли массив
- Если не заполнен, добавляем элемент
- Если заполнен, создается новый массив большего размера (в два раза больше) и копируются все элементы из старого массива в новый. Добавляем элемент в новый массив

Для удаления элемента из динамического массива достаточно просто удалить ссылку на элемент из массива и перераспределить индексы оставшихся элементов, чтобы заполнить создавшуюся пустую ячейку. При этом не происходит перевыделения памяти, как в случае добавления элемента в конец массива.

### Среднее время добавление элемента

Сложность добавления элемента в динамический массив зависит от того, насколько заполнен данный массив.
Существуют две ситуации

1. В массиве есть свободное место после последнего элемента за O(1)
2. Массив заполнен и нужно выделить новый участок памяти O(n), где n - количество элементов в массиве. Это связано с тем, что потребуется копирование всех элементов в новый участок памяти большего размера.

Так как второй случай происходит довольно редко, амортизационная сложность операции добавления элемента в динамический массив обычно составляет O(1), то есть постоянное время.

## 2. Односвязный список, двусвязный список. Псевдокод добавления и удаления.

### Односвязный список

**Определение** Односвязный список - это структура данных, состоящая из узлов (Node), каждый из которых содержит данные и ссылку на следующий узел.

**Реализация узла на джаве**

```java
class Node<T> {
    public T value; // значение данного узла
    public Node next; // ссылка на следующий
}
```

**Иллюстрация**

```
10 -> 20 -> 25 -> 30 -> 40 -> null

10 - tail
40 - tail
```

**Особенности**

Плюсы

- Возможность динамического изменения размера списка
- Не требуется непрерывной области памяти для хранения списка (узлы располагаются в памяти не последовательно, а в произвольных местах, а узлы связываются между собой посредством ссылок)

Минусы

- Для доступа к элементу по индексу требуется выполнить n шагов, где n - номер элемента в списке
- Расходует больше памяти, чем массивы, из-за необходимости хранить ссылки на следующие элементы

**Временная сложность**

- Добавление элемента в начало O(1)
- Обращение к HEAD O(1)
- Добавление элемента в конец O(n) (так как необходимо пройти весь список до его конца)
- Модификация элемента внутри списка O(n) (так как необходимо пройти весь список до нужного элемента)

### Двусвязный список

Теперь мы добавим к каждому узлу поле previous - ссылку на предыдущий элемент. Получится двусвязный список.

**Определение**
Двусвязный список — это структура данных, которая состоит из узлов, каждый из которых содержит ключ и ссылки на предыдущий и следующий узлы.

**Реализация узла на джаве**

```java
class Node<T> {
    public T value; // значение данного узла
    public Node next; // ссылка на следующий узел
    public Node prev; // ссылка на предыдущий узел
}
```

**Иллюстрация**

```
null <- 10 <--> 20 <--> 30 <--> 40 ->  null

10 - head
40 - tail
```

**Особенности**

Плюсы двусвязного списка

Плюсы

- Быстрое добавление и удаление элементов с начала и конца списка
- Доступ к элементу по индексу имеет лучшую производительность по сравнению с односвязным списком

Минусы

- Занимает больше памяти по сравнению с односвязным списком, так как каждый элемент имеет две ссылки на соседние элементы.
- Медленный доступ к элементам по индексу по сравнению с массивом.
- Требует дополнительных операций при вставке или удалении элементов, так как необходимо обновлять две ссылки на соседние элементы.

**Временная сложность**

- Добавление элемента в начало O(1)
- Обращение к HEAD/TAIL O(1)
- Добавление элемента в конец O(1)
- Модификация элемента внутри списка O(n) (так как необходимо пройти весь список до нужного элемента)
- Обращение к элементу внутри списка O(n) (так как необходимо пройти весь список до нужного элемента)

### Псевдокод добавления и удаления

Расскажу про добавление и удаление на двусвязном списке. Он сложнее чем на односвязном, поэтому если мы сделаем правильно процедуры с двусторонним, то с односторонним сделаем по аналогии.

**Добавление**

Добавлять можем по-разному. Можем добавить либо с головы/хвоста, либо по "индексу" справа и слева

Рассмотрим второй случай. Пусть у нас будет следующий список

```
null <- 10 <--> 20 <--> 40 ->  null
```

Между 20 и 40 необходимо вставить элемент с ключом 30.
Алгоритм следующий

- Создадим объект newnode класса Node, ссылки на prev и next
  будут содержать объекты с ключом 20 и 40 относительно
- Пройдемся по массиву, пока не найдем ключи 20 или 40
- Перепишем их ссылки на только что созданный объект newnode

```java

// добавим конструктор
class Node<T> {
    public int value;
    public Node next;
    public Node prev;

    public Node(int value, Node prev, Node next) {
        this.value = value;
        this.prev = prev;
        this.next = next;
    }
}


public void insertNode(Node prevNode, Node nextNode, int newValue) {
    Node<T> newNode = new Node(newValue, prevNode, nextNode);

    // Мы получили ссылки на  переписываем их
    prevNode.next = newNode;
    nextNode.prev = newNode;

}
```

А найдем мы эти объекты, просто пройдясь по списку от хвоста или головы

**Удаление**

Поступаем аналогично добавлению

```java
public void deleteNode(Node nodeToDelete):
    // если такого нет, заканчиваем работу
    if nodeToDelete == null:
        return

    // переназначаем соседей
    if nodeToDelete.prev != null:
        nodeToDelete.prev.next = nodeToDelete.next
    else:
        head = nodeToDelete.next

    if nodeToDelete.next != null:
        nodeToDelete.next.prev = nodeToDelete.prev
    else:
        tail = nodeToDelete.prev

    nodeToDelete = null
```

## 3. АТД Стек. Реализация стека на основе дин. массива, на основе списка.

### Стек

**Определение** Стек - это абстрактная структура данных. Стек - упорядоченная коллекция элементов, где доступ к элементам осуществляется только с одного конца, называемого вершиной стека.

**Принцип** FILO - First In Last Out

**Операции**

- push - положить элемент в стек
- pop - достать элемент из стека
- top/front - посмотреть элемент в вершине стека
- size - размер стека
- empty - проверить, пустой ли стек

**Временная сложность**

- push: O(1)
  (если реализациия на динамическом массиве, то O(n) в худшем случае)
- pop: O(1)
- top: O(1)
- size: O(1)
- empty: O(1)

## Реализация стека на основе динамического массива

**Пример работы стека**

1. До начала работы: пустой массив из двух элементов
2. Push 1: [1, 0] Size: 1 Capacity: 2
3. Push 2: [1, 2] Size: 2 Capacity: 2
4. Push 3.
   - Создаем новый массив размера в два раза большего предыдущего.
   - Поочередно копируем элементы старого массива в новый: [1, 2, 3, 0] Size: 3 Capacity: 4
5. Pop: [1, 2, 0, 0] Size: 2 Capacity: 4
6. Front: 2
7. Pop [1, 0, 0, 0] Size: 1 Capacity: 4

## Реализация стека на основе списка

Возьмем односвязный список. Он будет использоваться в качестве контейнера для хранения элементов стека.

В такой реализации стека, операция добавления и удаления элемента в стек происходит путем работы с **_первым_** элементом односвязного списка

**Пример работы стека**

1. До начала работы: нет node
2. Push 1: добавили Node с ключом 1 и ссылкой на null. Это наша голова и хвост
3. Push 2: Обратились к хвосту. Переписали ссылку на Node с ключом 2 и ссылкой на 1.
   Это **_новый хвост_**
4. Push 3. Обратились к хвосту. Переписали ее ссылку на Node с ключом 3 и ссылкой на 2.
   Это **_новый хвост_**

```
3 -> 2 -> 1
```

5. Pop:
   Обратимся к хвосту списка. Посмотрим на его next - это новый хвост. Старый хвост удаляем

```
2 -> 1
```

## 4. АТД Очередь и Дек. Реализация на основе списка, оценка времени сложности.

### Очередь

**Определение** Очередь - это структура данных, представляющая собой список элементов, в которой элементы добавляются в конец и удаляются из начала

**Принцип** FIFO - First In First Out

**Операции**

- push - положить элемент в очередь
- pop - достать первый элемент очереди
- front - посмотреть элемент в начале очереди
- size - размер очереди
- empty - проверить, является ли очередь пустой

### Реализация очереди на основе списка

Очередь реализована на массиве. Первый элемент очереди находится в начале массива, а последний - в его конце.

**Пример работы очереди**

1. До начала работы: пустой массив из двух элементов
2. Push 1: [0, 1] Size: 1 Capacity: 2
3. Push 2: [2, 1] Size: 2 Capacity: 2
4. Push 3: [0, 3, 2, 1]
   - Создаем новый массив размера в два раза большего предыдущего.
   - Поочередно копируем элементы старого массива в новый: [0, 0, 2, 1]
   - Добавляем новый элемент: [0, 3, 2, 1]
   - Size: 3 Capacity: 4
5. Pop: [0, 0, 2, 0] Size: 2 Capacity: 4
6. Front: 2

### Оценка времени сложности работы очереди

- push - сложность O(1), но в худшем случае может достигать O(n) из-за необходимости выделения нового массива.
- pop и front также имеют сложность O(1)
- size - O(1)
- empty - O(1)

### Дек aka deque (двусторонняя очередь)

Дек (Double Ended Queue) - это структура данных, которая позволяет добавлять и удалять элементы как в начале, так и в конце очереди.

**Операции**

- push_front - положить элемент в начало очереди
- push_back - положить элемент в конец очереди
- pop_front - достать первый элемент очереди
- pop_back - достать последний элемент очереди
- front - посмотреть элемент в начале очереди
- back - посмотреть элемент в конце очереди
- size - размер очереди

## 5. Бинарный поиск. Задача поиска элемента в отсортированном массиве - постановка задачи, оценка сложности алгоритма.

### Бинарный поиск

**Определение** Бинарный поиск - это алгоритм поиска элемента в отсортированном массиве. Он работает путем деления массива пополам и проверки, находится ли искомый элемент в левой или правой половинах массива. Данный процесс повторяется до тех пор, пока элемент не будет найден или пока не останется элементов для проверки.

**Алгоритм**

1. Два указателя на начало и конец массива L и R
   L - левая граница, на один элемент левее начала массива
   R - правая граница, на один элемент правее конца массива
2. Средний элемент mid = (L+R)/2
3. Если mid == x, то мы нашли x
4. Если x лежит слева от mid, то сдвигаем правую границу R = mid - 1
5. Если x лежит справа от mid, то сдвигаем левую границу L = mid + 1

// TODO узнать, будет ли спрашивать по правосторонний и левосторонний поиск.

### Задача поиска элемента в отсортированном массиве

**Постановка задачи**
Дан упорядоченный массив a длины n и элемент x. Необходимо определить, содержится ли элемент x в массиве a. Если да, то найти индекс первого вхождения элемента x в массиве.

**Решение**
Воспользуемся алгоритмом бинарного поиска. Будем последовательно делить отсортированный массив пополам, пока не найдем нужный элемент.

Сложность решения составляет O(log n), что значительно быстрее, чем простой перебор элементов массива, который имеет сложность O(n).

## 6. Поддержка минимума в стеке и очереди.

Для начала расскажем, что такое "Поддержка минимума". Под поддержкой минимума обычно понимается возможность быстрого получения минимального элемента из структуры данных, без необходимости перебирать все элементы.

### Стек

Для реализации поддержки минимума в стеке можно использовать дополнительный стек, в котором будут храниться минимальные элементы. Каждый раз при добавлении нового элемента в основной стек будем проверять, является ли он новым минимумом, и при необходимости добавлять его в дополнительный стек. При удалении элемента из основного стека будем также проверять, являлся ли он минимальным, и при необходимости удалять его из дополнительного стека.

### Очередь

Для реализации поддержки минимума в очереди можно использовать еще одну очередь. Одна будет очередью для обычных элементов, другая для минимумов

При реализации поддержки минимума в деке с использованием двух очередей каждый элемент хранится в одной из двух очередей в зависимости от того, насколько он меньше текущего минимума. Элементы, которые больше или равны текущему минимуму, хранятся в первой очереди, а элементы, которые меньше текущего минимума, хранятся во второй очереди.
Все элементы во второй очереди остаются в конце этой очереди, и это и есть минимумы.

В обоих случаях операции получения минимального элемента будут иметь временную сложность O(1). Будет достаточно получить верхний элемент из дополнительного стека или начальный элемент из дека.

## 7. Двоичная куча. Описание, построение, добавление элемента, извлечение максимума/минимума

### Описание двоичной кучи

**Определение** Двоичная куча - это структура данных, которая представляет собой ориентированное двоичное дерево. Для каждого узла x дерева соответствующий ему элемент ключ x не меньше (для максимальной кучи) или не больше (для минимальной кучи) ключей его потомков.

То есть у нас есть два типа кучи: максимальная и минимальная в зависимости от того, как элемент будет находиться в корне. Будем рассматривать в примерах максимальную кучу

### Построение

**Алгоритм создания кучи из массива**

1. Начинаем с середины массива, так как все узлы после середины являются листьями.
   Листья по умолчанию удовлетворяют свойству кучи.
2. Для каждого рассматриваемого узла сравним его значение со значениями его дочерних узлов.
   Поменяем местами узел с бОльшим дочерним узлом, если это необходимо для сохранения свойства максимальной/минимальной кучи.
3. Двигаемся вверх по дереву
   и повторяем шаг 2 для каждого узла, пока весь массив не будет удовлетворять свойству кучности.

Сложность: O(n)

**Пример**
Дан массив [13, 11, 7, 5, 6, 12]. Построим из него макс кучу

1. 6//2 - 1 = 2. Это индекс середины массива. Начинаем с элемента индексом 2, с 7
2. Сравниваем 7 с детьми (5,6,12). 12 больше 7, меняем 12 и 7.
   Получили [13, 11, 12, 5, 6, 7]
3. Двигаемся вперед к новому индексу. Сравниваем 11 с детьми (12, 5, 6, 7). Меняем 12 и 11 местами, так как 12 больше [13, 12, 11, 5, 6, 7]
4. Сравниваем 13 с детьми (12,11,5,6,7). 13 больше обоих двух детей, поэтому перестановок нет [13, 12, 11, 5, 6, 7]
5. Построим дерево

```
    13
   /   \
  12   11
 / \    \
 5 6     7
```

## Операции

- Построение кучи из неупорядоченного массива. В этом случае все элементы массива вставляются в кучу по одному с помощью операции вставки.
- Вставка нового элемента в кучу. Новый элемент вставляется в свободное место на дне кучи, а затем происходит перестройка кучи (sift up).
- Удаление максимального (первого) элемента из кучи. На место старого корня вставляется _последний_ (чтобы не нарушить остальные ряды) элемент, после чего происходит перестройка кучи (sift down).
- Получение максимального элемента из кучи. Для этого достаточно прочитать значение элемента в корне кучи.

**Операция sift up**

Новый элемент добавляется на последнее место кучи, а затем сравнивается с его родителем. Если родитель меньше добавленного элемента, то они меняются местами. Этот процесс продолжается до тех пор, пока добавленный элемент не окажется на своем месте.

**Операция sift down**

Последний элемент кучи перемещается на место корня, после чего он сравнивается со своими потомками. Если какой-то потомок больше корня, то они меняются местами. Этот процесс продолжается до тех пор, пока корень не окажется на своем месте.

**Временная сложность**

- Вставка элемента - O(log n)
- Получение максимального элемента - O(1)
- Удаление максимального элемента - O(log n)

## 8. Квадратичные сортировки (пузырьком, вставками, выбором), сортировка с помощью двоичной кучи. Описание алгоритмов, оценка времени работы и дополнительной памяти.

### Сортировка пузырьком

**Определение** Сортировка пузырьком — алгоритм сортировки, в котором сравниваются пары соседних элементов.
Если они стоят в неправильном порядке, то производится их обмен.

**Описание алгоритма**

1. Проходим по всем элементам массива слева направо.
2. Сравниваем каждую пару соседних элементов.
3. Если левый элемент больше правого, меняем их местами.
4. Повторяем шаги 1-3 для всех элементов, кроме последнего.
5. Проходим по массиву снова, но уже до предпоследнего элемента.
6. Повторяем шаги 2-5 до тех пор, пока массив не будет отсортирован.

**Пример работы**

Дан массив: [4, 1, 6, 9, 2]

- Итерация 1
  1. Сравниваем первый и второй элементы. 1 меньше 4, поэтому меняем их местами. [1, 4, 6, 9, 2]
  2. Сравниваем второй и третий элемент. 6 больше 4, не меняем местами. Массив: [1, 4, 6, 9, 2]
  3. 9 больше 6, не меняем местами. Массив: [1, 4, 6, 9, 2]
  4. 9 больше 2, меняем их местами. Массив: [1, 4, 6, 2, 9]
- Итерация 2
  1. 1 меньше 4, поэтому не меняем местами. Массив: [1, 4, 6, 2, 9]
  2. 4 меньше 6, поэтому не меняем местами. Массив: [1, 4, 6, 2, 9]
  3. Сравниваем третий и четвертый элемент. 6 больше 2, поэтому меняем их местами. Массив: [1, 4, 2, 6, 9]
  4. 6 меньше 9, поэтому не меняем местами. Массив: [1, 4, 2, 6, 9]
- Итерация 3
  1. 1 меньше 4, поэтому не меняем местами. Массив: [1, 4, 2, 6, 9]
  2. Сравниваем второй и третий элементы. 4 больше 2, поэтому меняем их местами. Массив: [1, 2, 4, 6, 9]
  3. 4 меньше 6, поэтому не меняем местами. Массив: [1, 2, 4, 6, 9]
  4. 6 меньше 9, поэтому не меняем местами. Массив: [1, 2, 4, 6, 9]

**Модификация алгоритма**

_Условие Айверсона-Тьюринга_ гласит, что если в процессе сортировки не было выполнено ни одной перестановки, то массив уже отсортирован.

То есть на каком-то этапе алгоритма все элементы могут встать на свои места.
Как проверить? Если мы пошли по массиву слева направо и не исправили ни одной инверсии, то массив уже отсортирован.

**Временная сложность** O(n^2)

**Дополнительная память** Не требуется

### Сортировка вставками

**Описание алгоритма**

0. Мысленно разбиваем массив на две части: отсортированную и неотсортированную.
1. Берем первый элемент неотсортированной части и вставляем его в отсортированную часть.
2. Расширяем отсортированную часть на один элемент.
3. Переходим к следующему элементу неотсортированной части, он будет следующим для сортировки. Сравниваем следующий элемент с предыдущим и меняем их местами, если они не отсортированы. Мы только что добавили еще один элемент в отсортированную часть.
4. Повторяем шаги 1-3, пока неотсортированная часть массива не окажется пустой

**Пример работы**

1. [2,5,6,1,9,1,1,10]
2. [2] [5,6,1,9,1,1,10]
3. [2,5] [6,1,9,1,1,10]
4. [2,5,6] [1,9,1,1,10]
5. "Проталкиваем влево" 1 в [2,5,6]
   - [2,5,6,1]
   - [2,5,1,6]
   - [2,1,5,6]
   - [1,2,5,6]
6. [1,2,5,6,9] [1,1,10]
7. "Проталкиваем влево" 1 в [1,2,5,6,9]
   - [1,2,5,6,9,1]
   - [1,2,5,6,1,9]
   - [1,2,5,1,6,9]
   - [1,2,1,5,6,9]
   - [1,1,2,5,6,9]
8. [1,1,2,5,6,9,1,10]
   ...
9. [1,1,1,1,2,5,6,9,10]

**Временная сложность** O(n^2)

**Дополнительная память** Не требуется

### Сортировка выбором

### Сортировка с помощью двойной кучи
