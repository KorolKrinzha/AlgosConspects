## 1. Статический массив. Динамический массив, среднее время добавления элемента.

### Статический массив

**Определение** Это структура данных, которая хранит элементы
одного типа в последовательности _с фиксированным размером_
Каждый элемент массива имеет уникальный индекс (начиная с 0) и хранит значение заданного типа.

**Создание массива** Для создания статического массива необходимо указать его размер,
который определяется на этапе компиляции программы.
Размер статического массива не может быть изменен в процессе выполнения.

Для создания статического массива в Java необходимо указать его тип, имя и размер

```java
int[] arr = new int[10]; // создание массива на 10 элементов типа int
```

**Работа со статическим массивом** Для доступа к элементам массива используется индекс, который указывает на позицию элемента в массиве. Индексы в Java начинаются с нуля.

```java
// Работаем с уже созданным массивом
arr[0] = 1; // назначили первый элемент массива
arr[1] = 2; // назначили второй элемент массива
arr[0] = 10; // переписали первый элемент массива
```

**Операции с массивами** Создание, удаление, модификация (добавление/удаление/переписывание) элементов, итерация по элементам, сортировка, копирование, поиск элемента

### Динамический массив

**Чем отличается от статического** Размер массива может меняться по ходе своей работы (то есть динамически)

**Реализация** В языке Java динамический массив представлен классом ArrayList

Как работает ArrayList под капотом?

- При создании создается массив фиксированного размера
- При добавлении нового элемента проверяем, заполнен ли массив
- Если не заполнен, добавляем элемент
- Если заполнен, создается новый массив большего размера (в два раза больше) и копируются все элементы из старого массива в новый. Добавляем элемент в новый массив

Для удаления элемента из динамического массива достаточно просто удалить ссылку на элемент из массива и перераспределить индексы оставшихся элементов, чтобы заполнить создавшуюся пустую ячейку. При этом не происходит перевыделения памяти, как в случае добавления элемента в конец массива.

### Среднее время добавление элемента

Сложность добавления элемента в динамический массив зависит от того, насколько заполнен данный массив.
Существуют две ситуации

1. В массиве есть свободное место после последнего элемента за O(1)
2. Массив заполнен и нужно выделить новый участок памяти O(n), где n - количество элементов в массиве. Это связано с тем, что потребуется копирование всех элементов в новый участок памяти большего размера.

Так как второй случай происходит довольно редко, амортизационная сложность операции добавления элемента в динамический массив обычно составляет O(1), то есть постоянное время.

## 2. Односвязный список, двусвязный список. Псевдокод добавления и удаления.

### Односвязный список

**Определение** Односвязный список - это структура данных, состоящая из узлов (Node), каждый из которых содержит данные и ссылку на следующий узел.

**Реализация узла на джаве**

```java
class Node<T> {
    public T value; // значение данного узла
    public Node next; // ссылка на следующий
}
```

**Иллюстрация**

```
10 -> 20 -> 25 -> 30 -> 40 -> null

10 - tail
40 - tail
```

**Особенности**

Плюсы

- Возможность динамического изменения размера списка
- Не требуется непрерывной области памяти для хранения списка (узлы располагаются в памяти не последовательно, а в произвольных местах, а узлы связываются между собой посредством ссылок)

Минусы

- Для доступа к элементу по индексу требуется выполнить n шагов, где n - номер элемента в списке
- Расходует больше памяти, чем массивы, из-за необходимости хранить ссылки на следующие элементы

**Временная сложность**

- Добавление элемента в начало O(1)
- Обращение к HEAD O(1)
- Добавление элемента в конец O(n) (так как необходимо пройти весь список до его конца)
- Модификация элемента внутри списка O(n) (так как необходимо пройти весь список до нужного элемента)

### Двусвязный список

Теперь мы добавим к каждому узлу поле previous - ссылку на предыдущий элемент. Получится двусвязный список.

**Определение**
Двусвязный список — это структура данных, которая состоит из узлов, каждый из которых содержит ключ и ссылки на предыдущий и следующий узлы.

**Реализация узла на джаве**

```java
class Node<T> {
    public T value; // значение данного узла
    public Node next; // ссылка на следующий узел
    public Node prev; // ссылка на предыдущий узел
}
```

**Иллюстрация**

```
null <- 10 <--> 20 <--> 30 <--> 40 ->  null

10 - head
40 - tail
```

**Особенности**

Плюсы двусвязного списка

Плюсы

- Быстрое добавление и удаление элементов с начала и конца списка
- Доступ к элементу по индексу имеет лучшую производительность по сравнению с односвязным списком

Минусы

- Занимает больше памяти по сравнению с односвязным списком, так как каждый элемент имеет две ссылки на соседние элементы.
- Медленный доступ к элементам по индексу по сравнению с массивом.
- Требует дополнительных операций при вставке или удалении элементов, так как необходимо обновлять две ссылки на соседние элементы.

**Временная сложность**

- Добавление элемента в начало O(1)
- Обращение к HEAD/TAIL O(1)
- Добавление элемента в конец O(1)
- Модификация элемента внутри списка O(n) (так как необходимо пройти весь список до нужного элемента)
- Обращение к элементу внутри списка O(n) (так как необходимо пройти весь список до нужного элемента)

### Псевдокод добавления и удаления

Расскажу про добавление и удаление на двусвязном списке. Он сложнее чем на односвязном, поэтому если мы сделаем правильно процедуры с двусторонним, то с односторонним сделаем по аналогии.

**Добавление**

Добавлять можем по-разному. Можем добавить либо с головы/хвоста, либо по "индексу" справа и слева

Рассмотрим второй случай. Пусть у нас будет следующий список

```
null <- 10 <--> 20 <--> 40 ->  null
```

Между 20 и 40 необходимо вставить элемент с ключом 30.
Алгоритм следующий

- Создадим объект newnode класса Node, ссылки на prev и next
  будут содержать объекты с ключом 20 и 40 относительно
- Пройдемся по массиву, пока не найдем ключи 20 или 40
- Перепишем их ссылки на только что созданный объект newnode

```java

// добавим конструктор
class Node<T> {
    public int value;
    public Node next;
    public Node prev;

    public Node(int value, Node prev, Node next) {
        this.value = value;
        this.prev = prev;
        this.next = next;
    }
}


public void insertNode(Node prevNode, Node nextNode, int newValue) {
    Node<T> newNode = new Node(newValue, prevNode, nextNode);

    // Мы получили ссылки на  переписываем их
    prevNode.next = newNode;
    nextNode.prev = newNode;

}
```

А найдем мы эти объекты, просто пройдясь по списку от хвоста или головы

**Удаление**

Поступаем аналогично добавлению

```java
public void deleteNode(Node nodeToDelete):
    // если такого нет, заканчиваем работу
    if nodeToDelete == null:
        return

    // переназначаем соседей
    if nodeToDelete.prev != null:
        nodeToDelete.prev.next = nodeToDelete.next
    else:
        head = nodeToDelete.next

    if nodeToDelete.next != null:
        nodeToDelete.next.prev = nodeToDelete.prev
    else:
        tail = nodeToDelete.prev

    nodeToDelete = null
```

## 3. АТД Стек. Реализация стека на основе дин. массива, на основе списка.

### Стек

**Определение** Стек - это абстрактная структура данных. Стек - упорядоченная коллекция элементов, где доступ к элементам осуществляется только с одного конца, называемого вершиной стека.

**Принцип** FILO - First In Last Out

**Операции**

      - push - положить элемент в стек
      - pop - достать элемент из стека
      - top/front - посмотреть элемент в вершине стека
      - size - размер стека
      - empty - проверить, пустой ли стек

**Временная сложность**

- push: O(1)
  (если реализациия на динамическом массиве, то O(n) в худшем случае)
- pop: O(1)
- top: O(1)
- size: O(1)
- empty: O(1)

## Реализация стека на основе динамического массива

**Пример работы стека**

1. До начала работы: пустой массив из двух элементов
2. Push 1: [1, 0] Size: 1 Capacity: 2
3. Push 2: [1, 2] Size: 2 Capacity: 2
4. Push 3.
   - Создаем новый массив размера в два раза большего предыдущего.
   - Поочередно копируем элементы старого массива в новый: [1, 2, 3, 0] Size: 3 Capacity: 4
5. Pop: [1, 2, 0, 0] Size: 2 Capacity: 4
6. Front: 2
7. Pop [1, 0, 0, 0] Size: 1 Capacity: 4

## Реализация стека на основе списка

Возьмем односвязный список. Он будет использоваться в качестве контейнера для хранения элементов стека.

В такой реализации стека, операция добавления и удаления элемента в стек происходит путем работы с **_первым_** элементом односвязного списка

**Пример работы стека**

1. До начала работы: нет node
2. Push 1: добавили Node с ключом 1 и ссылкой на null. Это наша голова и хвост
3. Push 2: Обратились к хвосту. Переписали ссылку на Node с ключом 2 и ссылкой на 1.
   Это **_новый хвост_**
4. Push 3. Обратились к хвосту. Переписали ее ссылку на Node с ключом 3 и ссылкой на 2.
   Это **_новый хвост_**

```
3 -> 2 -> 1
```

5. Pop:
   Обратимся к хвосту списка. Посмотрим на его next - это новый хвост. Старый хвост удаляем

```
2 -> 1
```

## 4. АТД Очередь и Дек. Реализация на основе списка, оценка времени сложности.

### Очередь

**Определение** Очередь - это структура данных, представляющая собой список элементов, в которой элементы добавляются в конец и удаляются из начала

**Принцип** FIFO - First In First Out

**Операции**

      * push - положить элемент в очередь
      * pop - достать первый элемент очереди
      * front - посмотреть элемент в начале очереди
      * size - размер очереди
      * empty - проверить, является ли очередь пустой

### Реализация очереди на основе списка

Очередь реализована на массиве. Первый элемент очереди находится в начале массива, а последний - в его конце.

**Пример работы очереди**

    * До начала работы: пустой массив из двух элементов
    * Push 1: [0, 1] Size: 1 Capacity: 2
    * Push 2: [2, 1] Size: 2 Capacity: 2
    * Push 3: [0, 3, 2, 1]
    - Создаем новый массив размера в два раза большего предыдущего.
    - Поочередно копируем элементы старого массива в новый: [0, 0, 2, 1]
    - Добавляем новый элемент: [0, 3, 2, 1]
    - Size: 3 Capacity: 4

- Pop: [0, 0, 2, 0] Size: 2 Capacity: 4
- Front: 2

### Оценка времени сложности работы очереди

- push - сложность O(1), но в худшем случае может достигать O(n) из-за необходимости выделения нового массива.
- pop и front также имеют сложность O(1)
- size - O(1)
- empty - O(1)

### Дек aka deque (двусторонняя очередь)

Дек (Double Ended Queue) - это структура данных, которая позволяет добавлять и удалять элементы как в начале, так и в конце очереди.

**Операции**

    * `push_front` - положить элемент в начало очереди
    * `push_back` - положить элемент в конец очереди
    * `pop_front` - достать первый элемент очереди
    * `pop_back` - достать последний элемент очереди
    * `front` - посмотреть элемент в начале очереди
    * `back` - посмотреть элемент в конце очереди
    * `size` - размер очереди

## 5. Бинарный поиск. Задача поиска элемента в отсортированном массиве - постановка задачи, оценка сложности алгоритма.

### Бинарный поиск

**Определение** Бинарный поиск - это алгоритм поиска элемента в отсортированном массиве. Он работает путем деления массива пополам и проверки, находится ли искомый элемент в левой или правой половинах массива. Данный процесс повторяется до тех пор, пока элемент не будет найден или пока не останется элементов для проверки.

**Алгоритм**

1. Два указателя на начало и конец массива L и R
   L - левая граница, на один элемент левее начала массива
   R - правая граница, на один элемент правее конца массива
2. Средний элемент mid = (L+R)/2
3. Если mid == x, то мы нашли x
4. Если x лежит слева от mid, то сдвигаем правую границу R = mid - 1
5. Если x лежит справа от mid, то сдвигаем левую границу L = mid + 1

// TODO узнать, будет ли спрашивать по правосторонний и левосторонний поиск.

### Задача поиска элемента в отсортированном массиве

**Постановка задачи**
Дан упорядоченный массив a длины n и элемент x. Необходимо определить, содержится ли элемент x в массиве a. Если да, то найти индекс первого вхождения элемента x в массиве.

**Решение**
Воспользуемся алгоритмом бинарного поиска. Будем последовательно делить отсортированный массив пополам, пока не найдем нужный элемент.

Сложность решения составляет O(log n), что значительно быстрее, чем простой перебор элементов массива, который имеет сложность O(n).

## 6. Поддержка минимума в стеке и очереди.

Для начала расскажем, что такое "Поддержка минимума". Под поддержкой минимума обычно понимается возможность быстрого получения минимального элемента из структуры данных, без необходимости перебирать все элементы.

### Стек

Для реализации поддержки минимума в стеке можно использовать дополнительный стек, в котором будут храниться минимальные элементы. Каждый раз при добавлении нового элемента в основной стек будем проверять, является ли он новым минимумом, и при необходимости добавлять его в дополнительный стек. При удалении элемента из основного стека будем также проверять, являлся ли он минимальным, и при необходимости удалять его из дополнительного стека.

### Очередь

Для реализации поддержки минимума в очереди можно использовать еще одну очередь. Одна будет очередью для обычных элементов, другая для минимумов

При реализации поддержки минимума в деке с использованием двух очередей каждый элемент хранится в одной из двух очередей в зависимости от того, насколько он меньше текущего минимума. Элементы, которые больше или равны текущему минимуму, хранятся в первой очереди, а элементы, которые меньше текущего минимума, хранятся во второй очереди.
Все элементы во второй очереди остаются в конце этой очереди, и это и есть минимумы.

В обоих случаях операции получения минимального элемента будут иметь временную сложность O(1). Будет достаточно получить верхний элемент из дополнительного стека или начальный элемент из дека.

## 7. Двоичная куча. Описание, построение, добавление элемента, извлечение минимума

### Двоичная куча

**Определение** Двоичная куча - это двоичное дерево. То есть ориентированный граф-дерево, у каждой вершины максимум два потомка
