# 1. Хеширование. Полиномиальная функция. Алгоритм Рабина-Карпа. Оценка времени выполнения функции

## Хеширование

### Определение хеширования

Хеширование - метод преобразования входных данных **произвольной длины в выходные данные фиксированной длины**. Для выполнения преобразования используется хеш-функция.

Хеш-функция берет входные данные и вычисляет выходные данные фиксированной длины, которые называются хеш-значением.

### Свойства хеш-значений и хеш-функций

- Равномерное распределение значений: хеш-функция стремится равномерно распределить хеш-значения по всем возможным выходным значениям. Это гарантирует минимальное количество коллизий и минимальную зависимость между входными данными и их хеш-значениями. Последнее означает, что небольшое изменение во входных данных должно вызывать значительное изменение в соответствующем хеш-значении.
- Уникальность: Каждый объект должен иметь уникальное хеш-значение. Это означает, что для разных объектов хеш-значения должны быть различными. Однако, возможны коллизии, когда двум разным объектам соответствует одно и то же хеш-значение.
- Детерминированность: Для одного и того же объекта хеш-функция всегда должна возвращать одно и то же хеш-значение.
- Эффективность: Вычисление хеш-значения должно занимать небольшое время в сравнении с общей сложность операций над объектами.

## Полиномиальная функция

Полиномиальная функция - математическая функция, которая задается выражением вида:

f(x) = aₙxⁿ + aₙ₋₁xⁿ⁻¹ + ... + a₂x² + a₁x + a₀,

где a₀, a₁, ..., aₙ - коэффициенты полинома, x - переменная, а n - степень полинома.

Степень полинома определяется максимальной степенью переменной в выражении. Например, в полиноме f(x) = 3x³ + 2x² + x + 1 степень полинома равна 3.

### Свойства полинома

- Коэффициенты: Коэффициенты полинома могут быть любыми числами, включая целые, дробные и комплексные числа. Они определяют вклад каждого члена полинома в его общую форму.
- Приближение функций: Полиномиальные функции могут быть использованы для приближения сложных функций с помощью более простых полиномов.
- Теорема о корнях полинома: Если полином P(x) имеет степень n, то он имеет ровно n корней (учитывая кратность) в комплексной области.

### Полиномиальный хеш

Полиномиальный хеш используется в алгоритме Рабин-Карпа

Полиномиальный хеш - это метод хеширования, который использует полиномиальную функцию для преобразования последовательности символов в числовое значение.

Принцип работы полиномиального хеша:

1. Каждому символу в алфавите назначается **уникальное** числовое значение.
2. Полиномиальная функция использует эти числовые значения символов для вычисления хеш-значения для каждой подстроки. Чаще всего используется формула:

```
hash = (s[0] * p^(n-1)) + (s[1] * p^(n-2)) + ... + (s[n-1] * p^0),

где s[i] - числовое значение символа на позиции i, p - выбранное простое число (база полинома), n - длина последовательности символов.

Возможны вариации формулы. Например,

hash = (s[0] * p^0) + (s[1] * p^1) + ... + (s[n-2] * p^(n-2)) + (s[n-1] * p^(n-1))
```

Важно отметить, что степенные функции p^(n-1), p^(n-2), ... обеспечивают различные веса для каждого символа в последовательности. Это позволяет получить уникальное хеш-значение для разных комбинаций одинаковых символов последовательностей символов.

3. Вычисленное хеш-значение используется для сравнения с хеш-значением подстрок текста. Если хеш-значения совпадают, то с большой вероятностью подстрока и искомая строка также совпадают.

Преимущество использования полиномиального хеша в сравнении подстрок заключается в том, что установление несоответствия подстрок происходит за (O(1)) вместо (O(m)) для обычного сравнения. Это делает алгоритм Рабин-Карпа эффективным для поиска подстрок в тексте.

## Алгоритм Рабина-Карпа

### Определение алгоритма Рабина-Карпа

Алгоритм Рабина-Карпа - алгоритм поиска строки, который ищет подстроку в тексте, используя хеширование.

Алгоритм Рабина-Карпа эффективен при поиске образца в тексте, особенно если искомая подстрока длинная и общая для нескольких текстовых блоков. Он может быть использован в различных приложениях, таких как поиск по тексту или фильтрация спама.

### Описание алгоритма Рабина-Карпа

1. С помощью полиномиальной хеш функции вычисляем хеш-значение подстроки, которую мы хотим найти. Вычисляем хеш-значения первой подстроки в целевой строке.
2. Затем алгоритм сравнивает хеш-значения нашей подстроки и текущей подстроки в целевой строке. Если хеш-значения совпадают, то алгоритм производит точное сравнение символов для проверки наличия полного совпадения.
3. Точное сравнение производится из-за коллизии хеш-значений, когда разные подстроки имеют одинаковые хеш-значения. Алгоритм проводит дополнительную проверку символов для исключения ложных срабатываний.
4. Если совпадение не найдено, **окно сравнения** сдвигается вправо на один символ, и новое хеш-значение вычисляется для следующей подстроки в целевой строке. Процесс повторяется до достижения конца строки или обнаружения совпадения.
5. Если полное совпадение найдено, алгоритм возвращает позицию первого символа подстроки в целевой строке.
6. При достижении конца строки алгоритм заканчивает работу.

### Время выполнения алгоритма

Существуют следующие случаи: худший, средний и лучший.

Худший случай O(nm): В случае, когда все символы текста и подстроки совпадают, алгоритм будет иметь худший случай временной сложности O(nm). Это происходит, когда все символы подстроки должны быть сравнены со всеми символами текста.

Средний случай O(n): В большинстве случаев, когда текст и подстрока не совпадают полностью, алгоритм имеет среднюю временную сложность O(n + m). Это связано с тем, что в большинстве случаев можно быстро отсеять несовпадающие подстроки с помощью сравнения хеш-значений.

Лучший случай O(n): В наилучшем случае, когда подстрока не найдена в тексте, алгоритм может иметь лучшую временную сложность O(n). Это происходит, когда сравнение хеш-значений подстроки и текста не дает совпадения, и алгоритм проходит по всем символам текста только один раз.

# 2. Z-функция. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения

Z-функция и π-функция являются алгоритмическими конструкциями, используемыми в строковых алгоритмах для эффективного нахождения подстрок в строке.

## Необходимые понятия

### Префикс

Префикс - подстрока, начинающаяся с первого символа исходной строки и имеющая длину, меньше или равную длине строки.

Например, для строки "abcd", все возможные префиксы это:

- Пустая строка "" (длина 0)
- "a" (длина 1)
- "ab" (длина 2)
- "abc" (длина 3)
- "abcd" (длина 4)

Собственный префикс — префикс, не совпадающий со всей строкой.

### Суффикс

Суффикс - это подстрока, которая начинается с определенной позиции и расширяется до конца строки.

Например, для строки "abcd", суффиксы будут следующими:

- Суффикс, начинающийся с позиции 0: "abcd"
- Суффикс, начинающийся с позиции 1: "bcd"
- Суффикс, начинающийся с позиции 2: "cd"
- Суффикс, начинающийся с позиции 3: "d"

Собственный суффикс — суффикс, не совпадающий со всей строкой

## Z-функция

### Определение Z-функции

Пусть дана строка s длины n. Тогда Z-функция от этой строки — это массив длины n, i-ый элемент которого равен **наибольшему числу символов, начиная с позиции i совпадающих с первыми i символами строки s**.

Иными словами, **z[i] — это наибольший общий префикс строки s и ее i-го суффикса.**

### Пример работы Z-функции

1. aaaaa

- z[0] = 0. z[0] всегда ноль
- z[1] = 4. Рассматриваем строку, которая начинается с элемента по индексу 1. Префикс новой строки совпадает с префиксом **изначальной строки** в четырех символах
- z[2] = 3. Рассматриваем строку aaa, aa|aaa. Префикс строки aaa совпадает с префиксом изначальной строки в трех символах.
- z[3] = 2. Новая строка aaa|aa.
- z[4] = 1. Новая строка aaaa|a.

Итого ответ следующий:

- z[0] = 0
- z[1] = 4
- z[2] = 3
- z[3] = 2
- z[4] = 1

2. aaabaab

- z[0] = 0. z[0] всегда ноль
- z[1] = 2. Новая строка aabaab. Она совпадает с изначальной строкой по следующим символам **|aa|** abaab.
- z[2] = 1. abaab. Совпадает с изначальной строкой по следующим символом **|a|** aabaab
- z[3] = 0. Суффикс равен "baab", а строка "aaabaab"
- z[4] = 2. Суффикс равен "aab"
- z[5] = 1. Суффикс равен "ab".
- z[6] = 0. Суффикс равен b. Не совпадает с префиксом aaabaab не совпадает

### Примение Z-функции

- С помощью Z-функции можно найти все вхождения заданной подстроки в строку за линейное время.

- Z-функция может быть применена для ускорения алгоритмов сопоставления строк, например, в алгоритме Кнута-Морриса-Пратта.

### Алгоритм построения

### Оценка времени выполнения

Временная сложность алгоритма построения Z-функции строки с длиной n равна O(n).

Алгоритм имеет линейную сложность, так как каждый символ строки обрабатывается только один раз в цикле.

## π-функция

### Определение

Пи-функция - определенная на строке функция, которая для каждой позиции в строке возвращает длину наибольшего собственного суффикса, который также является префиксом этой строки.

Дана строка s. Требуется вычислить для неё префикс-функцию, т.е. массив чисел pi, где pi[i] определяется следующим образом: это такая длина наибольшего собственного суффикса подстроки s[i], совпадающего с её префиксом.

### Пример

Дана строка "abcabcd"

- pi[0] = 0. Всегда равно нулю.
- pi[1] = 0. a из a|bcabcd - префикс, d из abcabc|d - суффикс. Они не совпадают.
- pi[2] = 0. ab и cd.
- pi[3] = 1. Это наша новая строка abca, наш префикс. В этой строке рассмотрим суффикс. Наибольшее совпадение между префиксом новой строки и ее суффиксом это один символ a.
- pi[4] = 2. Новая строка abcab. В этой строке рассмотрим суффикс. Наибольшее совпадение между префиксом новой строки и ее суффиксом это два символа ab, ab|c|ab.
- pi[5] = 3. Новая строка abcabc. В этой строке рассмотрим суффикс. Наибольшее совпадение между префиксом новой строки и ее суффиксом это три символа abc, abc|abc.
- pi[6] = 0.

  Результат: pi[0, 0, 0, 1, 2, 3, 0]

### Алгоритм построения

### Оценка времени выполнения

Временная сложность алгоритма построения π-функции строки с длиной n также равна O(n).

Алгоритм имеет линейную сложность, так как каждый символ строки обрабатывается только один раз в цикле.

# 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2+E). Улучшение алгоритма для разреженных графов за O(E\*logV)

## Определение алгоритма Дейксты

Алгоритм Дейкстры – это алгоритм на графах, используемый для нахождения кратчайшего пути от одной из вершин до всех остальных вершин взвешенного графа.

## Условия работы алгоритма Дейкстры

- отсутствие циклов отрицательного веса
- отсутствие отрицательных весов ребер

## Постановка задачи состоит в следующем

- Условие: Дан взвешенный граф G с N вершинами и M ребрами. Задана стартовая вершина S.
- Задача: Необходимо найти кратчайшие пути от вершины S до всех остальных вершин графа.

## Описание алгоритма за O(V^2+E)

1. Инициализируем массив с расстояниями. Вем вершинам графа назначаем "бесконечность", кроме начальной вершины, которой присваиваем значение 0.
2. Создаем пустое множество посещенных вершин.
3. На каждой итерации выбираем вершину с наименьшим текущим расстоянием из начальной вершины. Начально это будет сама начальная вершина.
4. Помечаем выбранную вершину как посещенную и рассматриваем расстояние до ее соседних вершин. Если новое расстояние до соседней вершины меньше текущего расстояния, то обновляем его.
5. Повторяем шаги 3 и 4 для всех оставшихся непосещенных вершин.
6. По завершении алгоритма для каждой вершины будет найдено кратчайшее расстояние от начальной вершины.

## Улучшение алгоритма для разреженных графов за O(E\*logV)

Улучшение достигается с помощью использования структуры данных, называемой минимальной кучей (в java это класс PriorityQueue). Каждая вершина - класс, в нем сохранены два параметра - значение вершины и текущее расстояние.

1. В множестве с расстояниями инициализируем все вершины графа значением "бесконечность", кроме начальной вершины, которой присваиваем значение 0.
2. Создаем пустую минимальную кучу, которая принимает непосещенные вершины графа.
3. Вставляем начальную вершину в приоритетную очередь с расстоянием 0.
4. Рассматриваем минимальную кучу. Пока она не пуста:
   - Извлекаем вершину с наименьшим текущим расстоянием из приоритетной очереди.
   - Помечаем извлеченную вершину как посещенную.
   - Для каждого соседа текущей вершины:
     - Если новое расстояние до соседа через текущую вершину меньше его текущего расстояния, обновляем его.
     - Вставляем соседа в приоритетную очередь с обновленным расстоянием.
5. По завершении алгоритма для каждой вершины будет найдено кратчайшее расстояние от начальной вершины.

### Оценка времени работы

Для понимания сложности O(E\*logV) алгоритма Дейкстры с использованием минимальной кучи, рассмотрим части алгоритма:

1. Создание и инициализация минимальной кучи: Этот шаг занимает O(V\*logV) времени, так как мы добавляем все V вершин в кучу, каждая операция добавления занимает O(logV) времени.
2. Итерационный процесс: Алгоритм выполняется V раз, по одной итерации для каждой вершины. На каждой итерации мы извлекаем вершину с наименьшим расстоянием из кучи, что занимает O(logV) времени.
3. Обновление расстояний: Для каждого ребра (u, v) алгоритм проверяет, можно ли улучшить расстояние до вершины v, пройдя через вершину u. Если это возможно, то происходит обновление расстояния и приоритета вершины v в куче. Всего есть E ребер в графе, поэтому этот шаг занимает O(E\*logV) времени.

Таким образом, общая сложность алгоритма Дейкстры с использованием минимальной кучи составляет O(VlogV) + O(VlogV) + O(E*logV), что приводит к O((V + E) * logV).

В сложности O((V + E) \* logV), выражение (V + E) обозначает общее количество операций, которые выполняются на протяжении алгоритма Дейкстры.

Однако, когда граф разреженный (то есть число ребер E мало по сравнению с числом вершин V^2), то E можно считать примерно равным V. Тогда формулу можно упростить:

O((V + E) \* logV) = O((V + V) \* logV) = O(2V \* logV) = O(V \* logV)

Таким образом, в случае разреженных графов, где E примерно равно V, сложность алгоритма Дейкстры с использованием минимальной кучи составляет O(E \* logV), что является оптимизированной сложностью для таких графов.

### Почему улучшение работает с разреженными графом

Извините за путаницу в предыдущих ответах. Независимо от числа ребер в графе, улучшение алгоритма Дейкстры с использованием минимальной кучи работает эффективно в случае разреженных графов. Позвольте мне объяснить это более ясно:

В классической версии алгоритма Дейкстры, где используется двумерный массив для хранения расстояний между вершинами, время выполнения составляет O(V^2), где V - количество вершин в графе. Это означает, что при увеличении числа вершин, время выполнения алгоритма растет квадратично.

Однако, когда граф является разреженным, то есть имеет небольшое количество ребер по сравнению с числом вершин, мы можем использовать улучшение алгоритма Дейкстры, которое работает за время O(E\*logV), где E - количество ребер, а V - количество вершин. В случае, когда граф не является разреженным, число ребер E может быть настолько большим, что O(E\*logV) \> O(V^2), что приводит к неэффективности данного подхода.

# 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке

## Определение динамического программирования

Динамическое программирование — это метод решения задач, основанный на **разбиении исходной задачи на более мелкие подзадачи**, решение каждой из которых производится один раз, после чего результаты **сохраняются для дальнейшего использования** при решении большей задачи.

Динамическое программирование часто используется для задач оптимизации, например, нахождения минимального пути или наибольшей подпоследовательности.

## Основные понятия

**Оптимальная подструктура** в динамическом программировании означает, что оптимальное **решение подзадач меньшего размера может быть использовано для решения исходной задачи**. В общем случае мы можем решить задачу, в которой присутствует оптимальная подструктура, проделывая следующие три шага:

1. Разбиение задачи на подзадачи меньшего размера.
2. Нахождение оптимального решения подзадач рекурсивно, проделывая такой же трёхшаговый алгоритм.
3. Использование полученного решения подзадач для конструирования решения исходной задачи.

В этом алгоритме решение задачи строится **путем рекурсивного разбиения ее на подзадачи и нахождения оптимальных решений для них**. Затем эти оптимальные решения сохраняются и используются для вычисления оптимального решения всей задачи.

Принцип оптимальности Беллмана является основной идеей динамического программирования. Он заключается в том, что **оптимальное решение задачи содержит в себе оптимальные решения ее подзадач**.
Более формально, принцип оптимальности Беллмана можно сформулировать следующим образом: Если задача может быть разбита на подзадачи, и оптимальное решение задачи можно выразить через оптимальные решения ее подзадач, то оптимальное решение всей задачи будет содержать в себе оптимальные решения подзадач.

В решении задач методами динамического программирования необходимо сохранять результаты вычислений для повторного использования. Этот процесс называется мемоизация. При использовании мемоизации результаты вычислений подзадач сохраняются в структуре данных (обычно в массиве или хеш-таблице), чтобы избежать повторных вычислений.

Итого, ключевые слова и понятия ДП: рекурсивное определение задач, принцип оптимальности Беллмана, оптимальные подструктуры, мемоизация

## Задача про кузнечика

Задача про кузнечика — это стандартный пример задачи, которая решается с помощью динамического программирования.

### Задача

найти количество способов, которыми кузнечик может добраться из начальной точки до точки N, прыгая только на 1 или 2 шага вперед.

### Решение

Создадим массив dp размером N+1, где dp[i] будет хранить количество способов, которыми кузнечик может добраться из точки 1 до точки i.

### Алгоритм

1. dp[0] равна нулю
2. Начальные значения dp[1] и dp[2] будут равны 1 и 2 соответственно - в первую он может прыгнуть только одним прыжком, во вторую с помощью двух одинарных прыжков и с помощью одного двойного
3. Затем мы будем заполнять массив dp с помощью цикла от 3 до N. Для каждого i мы будем находить сумму dp[i-1] и dp[i-2], так как кузнечик может добраться до точки i из точки i-1 или i-2. Таким образом, dp[i] будет равно количеству способов, которыми кузнечик может добраться до точки i.
4. В конце мы вернем значение dp[N], которое будет равно количеству способов, которыми кузнечик может добраться из точки 1 до точки N.

## Задача о черепашке

### Задача

Черепашка находится в левом верхнем углу сетки размером N x M и должна добраться до правого нижнего угла. Черепашка может двигаться только вниз или вправо. Каждая ячейка сетки имеет определенное значение, которое представляет стоимость прохождения черепашки через эту ячейку. Наша задача состоит в том, чтобы найти путь с минимальной стоимостью от начальной позиции до конечной позиции.

### Решение

Для решения этой задачи с использованием динамического программирования, мы можем создать дополнительную сетку размером N x M, где каждая ячейка будет содержать минимальную стоимость достижения этой ячейки из начальной позиции. Давайте назовем эту сетку dp.

### Алгоритм

1. Инициализируем первую строку и первый столбец сетки dp суммой стоимостей ячеек, по которым проходит черепашка.
2. Для каждой ячейки dp[i][j], где i>0 и j>0, вычисляем минимальную стоимость достижения этой ячейки, используя формулу:

```python
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
# dp[i-1][j] - движение влево
# dp[i][j-1] - движение вверх

# где grid[i][j] - это стоимость текущей ячейки
```

3. После прохода через всю сетку dp, значение dp[N-1][M-1] будет содержать минимальную стоимость достижения конечной позиции.
4. Таким образом, ответ на задачу будет равен dp[N-1][M-1].

# 5. Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы

## Определение задачи о рюкзаке

Задача о рюкзаке - это классическая задача комбинаторной оптимизации. У нас есть рюкзак определенной вместимости (пусть он задан максимальным весом), и у нас есть набор предметов, каждый из которых имеет свой вес и стоимость. Наша задача - выбрать определенный набор предметов, чтобы их суммарная стоимость была максимальной, при условии, что их суммарный вес не превышает вместимость рюкзака.

## Постановка задачи о рюкзаке

Дано: набор предметов с заданными весами, стоимостями и вместимость рюкзака.
Ограничения: каждый предмет может быть выбран только один раз (или 0 раз, то есть не выбран).
Цель: максимизировать суммарную стоимость выбранных предметов.

## Решение методом динамического программирования

Решение классической задачи о рюкзаке с помощью динамического программирования основывается на принципе **оптимальной подструктуры и повторных вычислениях**.

Алгоритм решения

1. Создаем двумерный массив dp размером (n+1) на (W+1), где n - количество предметов, W - вместимость рюкзака.

- Строки от 0 до n+1: Комбинация предметов, которые мы рассматриваем для упаковки в рюкзак. Индекс строки от 1 до n соответствует номеру предмета. Например, dp[1] будет соответствовать первому предмету, dp[2] - второму предмету и так далее.

Столбцы от 0 до W+1: Каждый столбец массива dp соответствует вместимости рюкзака для определенной вместимости. Например, dp[i][1] будет соответствовать вместимости рюкзака равной 1, dp[i][2] - вместимости 2 и так далее.

Таким образом, каждая ячейка dp[i][j] в массиве dp содержит максимальную стоимость, которую можно достичь с использованием предметов с индексами от 1 до i при вместимости рюкзака j.

2. Инициализируем первую строку dp нулями, так как при отсутствии предметов стоимость будет равна нулю.
3. Заполняем массив dp построчно и поэлементно с использованием рекуррентного соотношения.
   Для каждого предмета i (от 1 до n) и вместимости рюкзака j (от 1 до W) выполняем следующие шаги:

   - Если вес предмета i больше текущей вместимости j, то пропускаем его и оставляем значение dp[i][j] равным значению dp[i-1][j].
   - Если вес предмета i меньше или равен текущей вместимости j, то выбираем максимум из двух вариантов:
   - Не включать предмет i: dp[i][j] = dp[i-1][j].
   - Включить предмет i: dp[i][j] = стоимость предмета i + dp[i-1][j-вес предмета i], где второе слагаемое - это стоимость груза до добавление нового веса.
     Значение dp[i][j] будет равно максимальной стоимости из этих двух вариантов.

4. В итоге, максимальная стоимость, которую можно получить, будет находиться в ячейке dp[n][W].
5. Чтобы восстановить выбранный набор предметов, начинаем с ячейки dp[n][W] и движемся назад по массиву dp. Если значение dp[i][j] отличается от dp[i-1][j], значит предмет i был включен в рюкзак. Переходим к ячейке dp[i-1][j-вес предмета i] и продолжаем обратное движение до ячейки dp[1][1], восстанавливая выбранные предметы.

## Оценка времени работы

Временная сложность решения классической задачи о рюкзаке с помощью динамического программирования зависит от количества предметов n и вместимости рюкзака W.

Время выполнения программы составляет O(n \* W). Это связано с двойным циклом, с помощью которого мы проходимся по созданной матрице dp. Во время цикла мы рассматриваем каждый предмет и каждую возможную вместимость рюкзака.

# 6. Задача поиска наибольшей возрастающей подпоследовательности в массиве. Решение за O(N^2) методом динамического программирования. Решение за O(NlogN) методом динамического программирования

## Формулировка задачи

Задача поиска наибольшей возрастающей подпоследовательности в числовом массиве заключается в нахождении подпоследовательности элементов, которая строго возрастает и имеет максимальную длину.

Дано: массив arr
Задача: найти длину наибольшей возрастающей подпоследовательности

## Алгоритм решения задачи за O(N^2)

1. Создаем массив dp длины N, где N - количество элементов в исходном массиве. Инициализируем все элементы dp значением 1, так как каждый элемент сам по себе является возрастающей подпоследовательностью длины 1.
2. Проходимся по массиву элементов и для каждого элемента arr[i], начиная с индекса 1, сравниваем его со всеми предыдущими элементами arr[j], где j меньше i.
3. Если arr[i] больше arr[j], то значит мы можем продолжить предыдущую возрастающую подпоследовательность, добавив arr[i] к ней.
   Мы обновляем значение dp[i] путем выбора максимальной длины из dp[j] + 1 (длина предыдущей подпоследовательности, к которой мы добавляем текущий элемент) и текущего значения dp[i].

```python
dp[i] = max(dp[i], dp[j] + 1)
```

Это означает, что мы увеличиваем значение dp[i] только в случае, если добавление arr[i] к возрастающей подпоследовательности, заканчивающейся на arr[j], даст нам более длинную подпоследовательность.

4. Повторяем шаги 2-3 для всех элементов массива arr.
5. Находим максимальное значение в массиве dp, которое будет представлять длину наибольшей возрастающей подпоследовательности.

### Пример

0. arr = [3, 1, 5, 2, 4, 6]. dp = [1, 1, 1, 1, 1, 1]
1. arr[0] = 3. Не имеем предыдущих элементов, поэтому dp[1] остается 1
2. Для элемента arr[1] = 1.
   - arr[1]>arr[0] (1>3) - условие не выполняется, поэтому dp[1] остается 1

dp = [1, 1, 1, 1, 1, 1]

3. arr[2] = 5, сравниваем с предыдущими элементами:

- arr[2] > arr[0] (5 > 3), поэтому обновляем dp[2] = max(dp[2], dp[0]+1) = max(1, 1+1) = 2
- arr[2] > arr[1] (5 > 1), поэтому обновляем dp[2] = max(dp[2], dp[1] + 1) = max(2, 1 + 1) = 2.

dp = [1, 1, 2, 1, 1, 1]

4. arr[3] = 2, сравниваем с предыдущими элементами:
   - arr[3] > arr[0] (2 > 3) не выполняется, поэтому оставляем dp[3] = 1
   - arr[3] > arr[1] (2 > 1), поэтому обновляем dp[3] = max(dp[3], dp[1] + 1) = max(1, 1 + 1) = 2.
   - arr[3] > arr[2] (2 > 5), условие не выполняется, оставляем dp[3] = 2.

dp = [1, 1, 2, 2, 1, 1]

5. arr[4] = 4, сравниваем с предыдущими элементами:

   - arr[4] > arr[0] (4 > 3), поэтому обновляем dp[4] = max(dp[4], dp[0]+1) = max(1, 1+1) = 2
   - arr[4] > arr[1] (4 > 1), поэтому обновляем dp[4] = max(dp[4], dp[1] + 1) = max(2, 1 + 1) = 2.
   - arr[4] > arr[2] (4 > 5), условие не выполняется, оставляем dp[4] = 2.
   - arr[4] > arr[3] (4 > 2), поэтому обновляем dp[4] = max(dp[4], dp[3] + 1) = max(2, 2 + 1) = 3.

dp = [1, 1, 2, 2, 3, 1]

6. Для элемента arr[5] = 6, сравниваем с предыдущими элементами:
   - arr[5] > arr[0] (6 > 3), поэтому обновляем dp[5] = max(dp[5], dp[0] + 1) = max(1, 1 + 1) = 2.
   - arr[5] > arr[1] (6 > 1), поэтому обновляем dp[5] = max(dp[5], dp[1] + 1) = max(2, 1 + 1) = 2.
   - arr[5] > arr[2] (6 > 5), поэтому обновляем dp[5] = max(dp[5], dp[2] + 1) = max(2, 2 + 1) = 3.
   - arr[5] > arr[3] (6 > 2), поэтому обновляем dp[5] = max(dp[5], dp[3] + 1) = max(3, 2 + 1) = 3.
   - arr[5] > arr[4] (6 > 4), поэтому обновляем dp[5] = max(dp[5], dp[4] + 1) = max(3, 3 + 1) = 4.

dp = [1, 1, 2, 2, 3, 4]

## Алгоритм решения задачи за O(NlogN)

1. Создаем пустой массив tails, который будет хранить нарастающие подпоследовательности. Устанавливаем его первый элемент равным первому элементу исходного массива.
2. Проходим по остальным элементам исходного массива, начиная со второго элемента.
3. Для каждого элемента arr[i] выполняем бинарный поиск в массиве tails , чтобы найти самую правую позицию, на которую можно вставить arr[i] так, чтобы поддерживать возрастающую последовательность.
   - Если найденная позиция равна длине массива tails, то добавляем arr[i] в конец tails, так как он может продлить наибольшую возрастающую подпоследовательность.
   - В противном случае заменяем элемент в найденной позиции на arr[i], так как это обновление приводит к созданию новой возрастающей подпоследовательности, более длинной или равной предыдущей.
4. В конце процесса длина массива tails будет представлять длину наибольшей возрастающей подпоследовательности.

### Пример

0. arr = [3, 1, 5, 2, 4, 6]
1. Инициализируем массив tails с первым элементом arr[0]: tails = [3]
2. Рассматриваем arr[1] = 1:

   - Выполняем бинарный поиск в массиве tails. Так как 1 меньше элемента 3, найденная позиция равна 0.
   - Заменяем элемент в найденной позиции на 1.

tails = [1].

3.  Рассматриваем arr[2] = 5:
    - Выполняем бинарный поиск в массиве tails. Так как 5 больше всех элементов в tails, найденная позиция равна длине массива tails (1).
    - Добавляем 5 в конец массива tails.

tails = [1, 5].

4. Рассматриваем arr[3] = 2:
   - Выполняем бинарный поиск в массиве tails. Так как 2 меньше элемента 5, найденная позиция равна 1.
   - Заменяем элемент в найденной позиции на 2.

tails = [1, 2].

5. Рассматриваем arr[4] = 4:
   - Выполняем бинарный поиск в массиве tails. Так как 4 больше всех элементов в tails, найденная позиция равна длине массива tails (2).
   - Добавляем 4 в конец массива tails.

tails = [1, 2, 4].

6. Рассматриваем arr[5] = 6:

- Выполняем бинарный поиск в массиве tails. Так как 6 больше всех элементов в tails, найденная позиция равна длине массива tails (3).
- Добавляем 6 в конец массива tails

tails = [1, 2, 4, 6].

7. Длина наибольшей возрастающей подпоследовательности равна длине массива tails, то есть 4.

# 7. Задача поиска длины наибольшей общей подпоследовательности двух строк. Решение за O(n\*m) методом динамического программирования

## Постановка задачи

Дано: две строки s1 длиной n и s2 длиной m
Цель: найти длину наибольшей общей подпоследовательности двух строк

## Алгоритм решения

1. Создаем двумерный массив dp размером (n+1) x (m+1). Здесь dp[i][j] будет представлять длину наибольшей общей подпоследовательности для подстрок s1[0:i] и s2[0:j].
2. Инициализируем первую строку и первый столбец массива dp нулями, так как при пустых подстроках длина наибольшей общей подпоследовательности равна нулю.
3. Для каждого i от 1 до n и для каждого j от 1 до m:
   - Если s1[i-1] равно s2[j-1], то dp[i][j] равно dp[i-1][j-1] + 1. То есть, добавляем символы s1[i-1] и s2[j-1] к текущей общей подпоследовательности.
   - В противном случае, dp[i][j] равно максимуму между dp[i-1][j] и dp[i][j-1].
     То есть, выбираем наибольшую длину из подпоследовательности без символа s1[i-1] и подпоследовательности без символа s2[j-1].
4. По окончании заполнения массива dp, значение dp[n][m] будет содержать длину наибольшей общей подпоследовательности двух строк s1 и s2.

Алгоритм использует подзадачи, где мы сравниваем символы с конца строк. Заполняя массив dp построчно, мы постепенно увеличиваем длину подпоследовательности, сравнивая символы исходных строк и сохраняя промежуточные результаты.

## Пример

0.  Даны две строки "ABCDGH" и "AEDFHR", n = 6, m = 6
1.  Создаем двумерным массив размером 7x7
2.  Инициализируем первую строку и первый столбец массива dp нулями:

    |     |     | A   | E   | D   | F   | H   | R   |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |     | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
    | A   | 0   |     |     |     |     |     |     |
    | B   | 0   |     |     |     |     |     |     |
    | C   | 0   |     |     |     |     |     |     |
    | D   | 0   |     |     |     |     |     |     |
    | G   | 0   |     |     |     |     |     |     |
    | H   | 0   |     |     |     |     |     |     |

3.  s1[0]=s2[0], поэтому dp[1][1] = dp[0][0]+1 = 1
4.  s1[0]!=s2[1], поэтому dp[1][2] = max(dp[0][2], dp[1][1]) = max(0,1) = 1

    |     |     | A   | E   | D   | F   | H   | R   |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |     | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
    | A   | 0   | 1   | 1   |     |     |     |     |
    | B   | 0   |     |     |     |     |     |     |
    | C   | 0   |     |     |     |     |     |     |
    | D   | 0   |     |     |     |     |     |     |
    | G   | 0   |     |     |     |     |     |     |
    | H   | 0   |     |     |     |     |     |     |

5.  Продолжаем заполнять остальные ячейки аналогичным способом

    |     |     | A   | E   | D   | F   | H   | R   |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |     | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
    | A   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
    | B   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
    | C   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
    | D   | 0   | 1   | 1   | 2   | 2   | 2   | 2   |
    | G   | 0   | 2   | 2   | 2   | 2   | 2   | 2   |
    | H   | 0   | 2   | 2   | 2   | 2   | 3   | 3   |

6.  Значение dp[6][6] равно 3, что означает, что длина наибольшей общей подпоследовательности двух строк "ABCDGH" и "AEDFHR" равна 3.

Действительно, наибольшая общая подпоследовательность этих двух строк состоит из символов 'A', 'D' и 'H'.

## Оценка времени выполнения

Так как мы проходимся по матрице n\*m с помощью двойного цикла, время выполнения программы будет составлять O(n\*m).

# Дерево отрезков

// TODO переделать алгоритм построения, пример построения. Написать операции

## Определение

Дерево отрезков (Segment Tree) - это структура данных, которая представляет собой бинарное дерево, где каждый узел соответствует некоторому отрезку массива.

В дереве отрезков каждый узел хранит информацию о сумме, минимуме, максимуме или другой функции значений на соответствующем отрезке массива. Корень дерева представляет весь массив, а каждый узел дробит его на две половины. Левый и правый потомки узла представляют левую и правую половины отрезка. Листья дерева - отдельные элементы массива

## Использование дерева отрезков

Общая идея дерева отрезков заключается в том, чтобы предварительно обработать массив и построить структуру данных, которая позволяет эффективно выполнять различные операции на отрезках. Выбор конкретных операций зависит от требований задачи.

## Пример дерева отрезка

```
     36 [0-5]
   /    \
  9      27
 / \    /  \
 4  *5  16  *11
/  \    / \
*1  *3  *7 *9
```

В данном дереве листья 1,3,5,7,9 и 11 - элементы массива. Каждая остальная вершина - операция сложения потомков. Например, 4 = 1+3 или 27 = (7+9) + 11

## Варианты деревьев отрезков

Ниже представлены некоторые примеры возможных типов деревьев

1. Суммовое дерево отрезков (Segment Tree): В этом типе дерева отрезков каждый узел хранит сумму значений в соответствующем отрезке массива.
2. Минимальное/Максимальное дерево отрезков: В этом типе дерева отрезков каждый узел хранит минимальное или максимальное значение в соответствующем отрезке массива.
3. Дерево отрезков для операции XOR: В этом типе дерева отрезков каждый узел хранит результат операции XOR для соответствующего отрезка массива.
4. Дерево отрезков для операции НОД (наибольший общий делитель): В этом типе дерева отрезков каждый узел хранит наибольший общий делитель для соответствующего отрезка массива.

## Построение дерева отрезков

### Алгоритм построения дерева отрезков сумм из массива

1. Задаем исходный массив чисел arr, на основе которого будет строиться дерево отрезков.
2. Создаем пустое дерево отрезков tree = arr\*4.
3. Вызываем рекурсивную функцию для построения дерева отрезков. Входными параметрами функции являются:
   - Индекс текущего узла в дереве отрезков (начиная с корневого узла с индексом 1).- Границы отрезка массива, который соответствует текущему узлу. На первом вызове границы будут равны начальному и конечному индексам массива.
4. В рекурсивной функции проверяем, является ли текущий узел листовым узлом.
   - Если это лист, присваиваем значение этому узлу из исходного массива.
   - Если текущий узел не является листом, то разбиваем отрезок текущего узла пополам и рекурсивно вызываем функцию для создания левого и правого поддерева.
5. В каждом вызове функции получаем сумму значений левого и правого поддерева и присваиваем эту сумму текущему узлу.
6. По завершении рекурсивных вызовов получаем полностью построенное дерево отрезков.

### Пример построения дерева отрезков

## Время выполнения алгоритма

Временная сложность построения дерева отрезков зависит от размера исходного массива чисел. Построение дерева отрезков для суммы элементов на отрезках имеет временную сложность O(N), где N - размер исходного массива.

# 8. Поиск суммы на отрезке + изменение значения в массиве. Постановка задачи, решение за O(logN) при помощи дерева отрезков. Построение дерева отрезков.

## Постановка задачи

Необходимо реализовать алгоритм для поиска суммы элементов в массиве на заданном отрезке, который будет работать при заданных и обновленных элементов в массиве.

## Решение

Воспользуемся деревом отрезков, которые мы уже обсудили. К уже созданному дереву отрезков нужно добавить две операции - операция сложения отрезков и обновления дерева

## Обновление дерева отрезка

### Алгоритм обновление дерева отрезка

1. Начнем с корневого узла дерева отрезков.
2. Если текущий узел представляет отрезок, в котором содержится изменяемый элемент, перейдите к его дочерним узлам и повторите шаг 2 для соответствующего подотрезка.
3. Когда достигнут листовой узел, обновите значение этого узла, соответствующее измененному элементу в исходном массиве.
4. Поднимитесь обратно по пути от листового узла к корневому узлу, обновляя значения узлов в соответствии с новыми значениями дочерних узлов.
5. Повторите шаги 2-4 для всех изменяемых элементов в массиве.

### Временная сложность

Изменение значения элемента требует обновления только части дерева, которая содержит этот элемент. Временная сложность обновления дерева отрезков составляет O(logN)

## Вычисление суммы на отрезке

# 9. Поиск минимума на отрезке + изменение значения в массиве. Постановка задачи, решение за O(log N) при помощи дерева отрезков. Построение дерева отрезков.

Аналогично билету 8.

# 10. Алгоритм Форда-Беллмана. Описание алгоритма. Оценка времени выполнения

## Определение алгоритма Форда-Беллмана

Алгоритм Беллмана-Форда - это алгоритм поиска кратчайшего пути во взвешенном ориентированном графе с возможными отрицательными весами ребер.

## Условие работы алгоритма Форда-Беллмана

- Отсутствие отрицательных циклов в графе

Отрицательный цикл в графе - это цикл, сумма весов ребер которого отрицательна.
Он может привести к бесконечному уменьшению стоимости пути. Если в графе присутствует отрицательный цикл, то мы можно обойти его бесконечное количество раз и уменьшить стоимость пути. Это не соответствует нашей задаче

## Описание алгоритма

1. Инициализация

   - Задаем начальную вершину start исходного графа.
   - Создаем массив расстояний
   - Устанавливаем расстояние в массиве до всех вершин, кроме start, равным бесконечности, а расстояние до start равным 0.

2. Релаксация ребер

   - Проходим по всем E ребрам графа.
   - Для каждого ребра (u, v) проверяем, можно ли улучшить расстояние до вершины v через вершину u. Если да, то обновляем расстояние до v на значение

   ```python
   dist[v] = dist[u] + weight(u, v)
   # где dist[u] — текущее расстояние до вершины u, а weight(u, v) — вес ребра (u, v).
   ```

3. Проверка наличия отрицательных циклов

- Проходим по всем ребрам графа E еще раз.
- Если мы можем улучшить расстояние до вершины v через вершину u, то это означает наличие отрицательного цикла в графе. В этом случае алгоритм не может найти оптимальные расстояния, и мы завершаем его с сообщением о наличии отрицательного цикла.

4. Вывод результатов

## Временная сложность

Временная сложность алгоритма Беллмана-Форда - O(VE), где V - число вершин графа, E - число ребер графа.

## Дополнительная память

Затраты памяти алгоритма Беллмана-Форда составляют O(V), где V - количество вершин в графе. Это связано с тем, что для каждой вершины мы храним ее минимальное расстояние от начальной вершины dist[v].

# 11. Алгоритм Флойда-Уоршелла. Описание алгоритма. Оценка времени выполнения

## Определение алгоритма Флойда-Уоршелла

Алгоритм Флойда-Уоршелла - алгоритм, используем для нахождения кратчайшего пути взвешенного графа с положительными или отрицательными весами ребер, не имеющего циклов отрицательного веса.

## Принцип работы и особенности

Алгоритм работает в несколько этапов и основан на идее **динамического программирования**.

### Подход к решению

Алгоритм Флойда-Уоршелла и алгоритм Форда-Беллмана являются двумя различными алгоритмами для решения задачи поиска кратчайших путей во взвешенном ориентированном графе с отрицательными весами. Алгоритм Флойда-Уоршелла использует подход "динамического программирования", где каждая итерация обновляет расстояния между всеми парами вершин.

### Временная сложность

Временная сложность алгоритма Форда-Беллмана составляет O(V \* E), где V - количество вершин, а E - количество ребер в графе. В то время как алгоритм Флойда-Уоршелла имеет временную сложность O(V^3), где V - количество вершин.

Таким образом, **алгоритм Форда-Беллмана эффективнее для разреженных графов, в то время как алгоритм Флойда-Уоршелла более эффективен для плотных графов**.

### Обработка отрицательных циклов

Алгоритм Форда-Беллмана способен обнаруживать наличие отрицательных циклов в графе, что является его особенностью. Алгоритм Флойда-Уоршелла, напротив, не обнаруживает отрицательные циклы явно во время работы.

### Итого

Алгоритм Флойда-Уоршелла лучше подходит для поиска кратчайших путей в плотных графах без отрицательных циклов.

## Алгоритм

1. Создаем квадратную матрицу расстояний размером V x V, где V - количество вершин в графе. Изначально заполняем ее значениями весов ребер графа. Если между двумя вершинами нет прямого ребра, то в соответствующую ячейку матрицы записываем бесконечность.
2. Проходим по всем парам вершин (i, j), где i и j - индексы текущей промежуточной вершины. Для каждой пары вершин выполняем следующие действия:

- Если значение расстояния от i до j **через текущую промежуточную вершину** меньше, чем текущее значение расстояния между i и j, то обновляем значение расстояния.

3. Повторяем шаг 2 для каждой промежуточной вершины.
4. После завершения алгоритма в матрице расстояний будут содержаться кратчайшие расстояния между всеми парами вершин.
5. (дополнительно) Можно проверить наличие отрицательных циклов, пройдя по диагонали матрицы расстояний. Если на главной диагонали есть отрицательные значения, это указывает на наличие отрицательного цикла в графе.

# 12. Двоичные деревья поиска. Описание структуры. Операции: построение, удаление, вставка. Асимптотика операций

## Определение бинарного дерева поиска

Бинарное дерево поиска (двоичное дерево поиска) - это структура данных, представляющая собой дерево, где каждый узел содержит ключ и два поддерева, левое и правое, каждое из которых также является бинарным деревом поиска.

Каждое бинарное дерево удовлетворяет двум следующим условиям:

1. Все элементы **левого** поддерева должны быть **меньше текущего элемента**
2. Все элементы **правого** поддерева должна быть **больше текущего элемента**

## Пример бинарного дерева

```
      8
   /    \
  3     10
 / \    / \
 1  6      14
 /\/ \     / \
   4  7   13
```

## Использование

Одной из главных особенностей бинарного дерева поиска является то, что элементы хранятся в упорядоченном виде. Это позволяет выполнять операции **поиска, вставки и удаления элементов** за оптимальное время

## Асимптотика основных операций

- Поиск элемента: O(log n)
- Вставка элемента: O(log n)
- Удаление элемента: O(log n)
- Минимальный/максимальный элемент: O(log n)
- Обход всех элементов в отсортированном порядке: O(n)

Данная асимптотика возможна в сбалансированном дереве. Однако, в несбалансированных деревьях время выполнения всех перечисленных операций стремится к n.

### Пример худшего случая

В качестве примера рассмотрим следующее несбалансированное дерево (оно называется линейным):

```python
1 -> 2 -> 3 -> 4 -> 5 -> null
```

Если мы хотим добавить в дерево 6, нам придется пройтись по всем n элементам, чтобы сравнить текущий с ними и положить 6 в конец.

## Обзор операций с бинарным деревом

Мы рассмотрим и опишем следующий функционал

- Поиск элемента по ключу
- Вставка нового элемента в дерево
- Удаление элемента из дерева
- Обход элементов дерева
  - прямой (pre-order)
  - симметричный (in-order)
  - обратный (post-order)

### Добавление узла

1. Начинаем с корневого узла. Сравниваем ключ добавляемого узла со значением ключа текущего узла.
2. Если ключ добавляемого узла меньше текущего узла, переходим к левому поддереву.
3. Если ключ добавляемого узла больше текущего узла, переходим к правому поддереву.
4. Если соответствующего поддерева не существует, создаем его и добавляем новый узел.
5. Если ключ добавляемого узла равен ключу текущего узла, то заменяем значение текущего узла на значение добавляемого узла.

Если бы мы хотели добавить 6, то нам пришлось пройти через все элементы

В сбалансированном дереве, когда высота дерева log(n), сложность операции добавления узла составляет O(log(n)).

### Удаление узла

Алгоритм удаления узла из бинарного дерева состоит из следующих шагов:

1. Начинаем с корневого узла и идем по дереву, пока не найдем узел, который нужно удалить. Если такого узла нет, то операция завершается без изменений.
2. Если найденный узел не имеет дочерних узлов, то он просто удаляется.
3. Если найденный узел имеет только одного потомка, то этот потомок заменяет удаляемый узел.
4. Если найденный узел имеет двух потомков, то нужно найти узел с наименьшим значением в правом поддереве удаляемого узла (чтобы сохранить свойство дерева - все остальные **в правой ветке** будут **больше родителя**). Этот узел заменит удаляемый узел, а потомки удаляемого узла станут потомками найденного узла.

### Поиск по ключу

0. Поиск по ключу в бинарном дереве поиска начинается с корневого узла.
1. Если ключ, который мы ищем, равен ключу корневого узла, то мы нашли нужный узел и завершаем поиск.
2. Если ключ, который мы ищем, меньше ключа корневого узла, то мы продолжаем поиск в левом поддереве корневого узла. Сравниваем элемент с "корнем" текущего поддерева.
3. Если ключ, который мы ищем, больше ключа корневого узла, то мы продолжаем поиск в правом поддереве корневого узла. Сравниваем элемент с "корнем" текущего поддерева.
4. Повторяем шаги 1-3, пока не алгоритм не закончится.

### Нахождение предыдущего элемента

Задание "найти предыдущий узел относительно заданного ключа" означает поиск в бинарном дереве поиска узла **с максимальным ключом, который меньше, чем заданный ключ**

1. Находим узел с заданным ключом с помощью алгоритма поиска по ключу.
2. Проверяем у искомого узла, есть ли у него **левый потомок**. Если есть, то переходим к этому потомку и затем идем вправо до тех пор, пока не дойдем до узла, у которого нет правого потомка (идем **"вниз вправо"**). Этот узел и будет предыдущим по отношению к искомому узлу.
3. Если у искомого узла нет левого потомка, то идем по всем родительским узлам до тех пор, пока текущий узел не станет левым потомком своего родителя ("поднимаемся влево"). Родитель этого узла и будет предыдущим по отношению к искомому узлу.

### Нахождение следующего элемента

Задание "найти следующий узел относительно заданного ключа" означает поиск в бинарном дереве поиска узла **с минимальным ключом, который больше, чем заданный ключ**

Алгоритм поиска следующего узла по ключу в бинарном дереве поиска работает следующим образом:

1. Находим узел с заданным ключом с помощью алгоритма поиска по ключу.
2. Если **правое поддерево** найденного узла не пустое, то ищем в нём узел с минимальным ключом (то есть **"спускаемся влево"**). Это будет следующий узел по ключу.
3. Если правое поддерево пустое, то идём вверх по дереву, пока текущий узел является правым потомком своего родителя, и продолжаем поиск вверх по дереву до тех пор, пока не найдём первый узел, который является левым потомком своего родителя. (то есть "поднимаемся вправо") Его ключ будет следующим по порядку.

## Обход элементов дерева

### Прямой

Прямой обход дерева - это обход дерева, при котором сначала посещается корень дерева, затем левое поддерево и затем правое поддерево.

Для каждого узла в дереве алгоритм прямого обхода выполняет следующие операции:

1. Посещаем корневой узел
2. Рекурсивно посещаем левое поддерево, выполняя обход для его корневого узла
3. Рекурсивно посещаем правое поддерево, выполняя обход для его корневого узла

### Симметричный

Симметричный обход бинарного дерева заключается в том, что сначала посещается левое поддерево, затем текущий узел, и затем правое поддерево.

Алгоритм симметричного обхода:

1. Проверяем, что текущий узел не является пустым.
2. Рекурсивно вызываем симметричный обход для левого поддерева текущего узла.
3. Обрабатываем значение ключа текущего узла.
4. Рекурсивно вызываем симметричный обход для правого поддерева текущего узла.

В результате обхода, узлы дерева будут обработаны **в порядке возрастания ключей**.

### Обратный

Обратный обход бинарного дерева (инфиксный обход) происходит в следующем порядке: сначала рекурсивно обходим левое поддерево, затем правое поддерево, а затем посещаем текущий узел.

Алгоритм обратного обхода:

1. Если текущий узел равен null, то ничего не делаем и выходим из функции.
2. Рекурсивно обходим левое поддерево.
3. Рекурсивно обходим правое поддерево.
4. Посещаем текущий узел

Этот обход сначала рассматривает все листья дерева, затем их родителей и т.д., пока не дойдет до корня дерева.

## Нахождение минимума и максимума

Алгоритм поиска минимума в бинарном дереве поиска:

1. Начинаем обход дерева с корня
2. Если левый потомок существует, переходим к нему
3. Если левый потомок отсутствует, текущий узел является узлом с минимальным значением ключа
