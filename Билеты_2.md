# 1. Хеширование. Полиномиальная функция. Алгоритм Рабина-Карпа. Оценка времени выполнения функции

## Хеширование

### Определение хеширования

Хеширование - метод преобразования входных данных произвольной длины в выходные данные фиксированной длины с помощью хеш-функции. Для выполнения преобразования используется хеш-функция.

Хеш-функция берет входные данные и вычисляет выходные данные фиксированной длины, которые называются хеш-значением.

### Свойства хеш-значений и хеш-функций

- Равномерное распределение значений: хеш-функция стремится равномерно распределить хеш-значения по всем возможным выходным значениям. Это гарантирует минимальное количество коллизий и минимальную зависимость между входными данными и их хеш-значениями. Последнее означает, что небольшое изменение во входных данных должно вызывать значительное изменение в соответствующем хеш-значении.
- Уникальность: Каждый объект должен иметь уникальное хеш-значение. Это означает, что для разных объектов хеш-значения должны быть различными. Однако, возможны коллизии, когда двум разным объектам соответствует одно и то же хеш-значение.
- Детерминированность: Для одного и того же объекта хеш-функция всегда должна возвращать одно и то же хеш-значение.
- Эффективность: Вычисление хеш-значения должно занимать небольшое время в сравнении с общей сложность операций над объектами.

## Полиномиальная функция

Полиномиальная функция - математическая функция, которая задается выражением вида:

f(x) = aₙxⁿ + aₙ₋₁xⁿ⁻¹ + ... + a₂x² + a₁x + a₀,

где a₀, a₁, ..., aₙ - коэффициенты полинома, x - переменная, а n - степень полинома.

Степень полинома определяется максимальной степенью переменной в выражении. Например, в полиноме f(x) = 3x³ + 2x² + x + 1 степень полинома равна 3.

### Свойства полинома

- Коэффициенты: Коэффициенты полинома могут быть любыми числами, включая целые, дробные и комплексные числа. Они определяют вклад каждого члена полинома в его общую форму.
- Значения и корни: Полиномиальные функции могут быть использованы для нахождения значений функции при заданных значениях переменной. Также они используются для нахождения корней полинома, то есть значений переменной, при которых функция равна нулю.
- Приближение функций: Полиномиальные функции могут быть использованы для приближения сложных функций с помощью более простых полиномов.

### Теорема о корнях полинома

Если полином P(x) имеет степень n, то он имеет ровно n корней (учитывая кратность) в комплексной области.

### Полиномиальный хеш

Полиномиальный хеш используется в алгоритме Рабин-Карпа

Полиномиальный хеш - это метод хеширования, который использует полиномиальную функцию для преобразования последовательности символов в числовое значение.

Принцип работы полиномиального хеша:

1. Каждому символу в алфавите назначается **уникальное** числовое значение.
2. Полиномиальная функция использует эти числовые значения символов для вычисления хеш-значения для каждой подстроки. Чаще всего используется формула:

```
hash = (s[0] * p^(n-1)) + (s[1] * p^(n-2)) + ... + (s[n-1] * p^0),

где s[i] - числовое значение символа на позиции i, p - выбранное простое число (база полинома), n - длина последовательности символов.
```

Важно отметить, что степенные функции p^(n-1), p^(n-2), ... обеспечивают различные веса для каждого символа в последовательности. Это позволяет получить уникальное хеш-значение для разных комбинаций одинаковых символов последовательностей символов. 3. Вычисленное хеш-значение используется для сравнения с хеш-значением подстрок текста. Если хеш-значения совпадают, то с большой вероятностью подстрока и искомая строка также совпадают.

Преимущество использования полиномиального хеша в сравнении подстрок заключается в том, что установление несоответствия подстрок происходит за (O(1)) вместо (O(m)) для обычного сравнения. Это делает алгоритм Рабин-Карпа эффективным для поиска подстрок в тексте.

## Алгоритм Рабина-Карпа

### Определение алгоритма Рабина-Карпа

Рабин-Карп - алгоритм поиска строки, который ищет подстроку в тексте, используя хеширование.

Алгоритм Рабина-Карпа эффективен при поиске образца в тексте, особенно если искомая подстрока длинная и общая для нескольких текстовых блоков. Он может быть использован в различных приложениях, таких как поиск по тексту или фильтрация спама.

### Описание алгоритма Рабина-Карпа

1. С помощью полиномиальной хеш функции вычисляем хеш-значение подстроки, которую мы хотим найти. Вычисляем хеш-значения первой подстроки в целевой строке.
2. Затем алгоритм сравнивает хеш-значения нашей подстроки и текущей подстроки в целевой строке. Если хеш-значения совпадают, то алгоритм производит точное сравнение символов для проверки наличия полного совпадения.
3. Точное сравнение производится из-за коллизии хеш-значений, когда разные подстроки имеют одинаковые хеш-значения. Алгоритм проводит дополнительную проверку символов для исключения ложных срабатываний.
4. Если совпадение не найдено, **окно сравнения** сдвигается вправо на один символ, и новое хеш-значение вычисляется для следующей подстроки в целевой строке. Процесс повторяется до достижения конца строки или обнаружения совпадения.
5. Если полное совпадение найдено, алгоритм возвращает позицию первого символа подстроки в целевой строке.
6. При достижении конца строки алгоритм заканчивает работу.

### Время выполнения алгоритма

Существуют следующие случаи: худший, средний и лучший.

Худший случай O(nm): В случае, когда все символы текста и подстроки совпадают, алгоритм будет иметь худший случай временной сложности O(nm). Это происходит, когда все символы подстроки должны быть сравнены со всеми символами текста.

Средний случай O(n): В большинстве случаев, когда текст и подстрока не совпадают полностью, алгоритм имеет среднюю временную сложность O(n + m). Это связано с тем, что в большинстве случаев можно быстро отсеять несовпадающие подстроки с помощью сравнения хеш-значений.

Лучший случай O(n): В наилучшем случае, когда подстрока не найдена в тексте, алгоритм может иметь лучшую временную сложность O(n). Это происходит, когда сравнение хеш-значений подстроки и текста не дает совпадения, и алгоритм проходит по всем символам текста только один раз.

// TODO: добавить код алгоритма в Билеты_Код_2.md

# 2. Z-функция. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения

Z-функция и π-функция являются алгоритмическими конструкциями, используемыми в строковых алгоритмах для эффективного нахождения подстрок в строке.

### Z-функция

### Определение Z-функции

Z-функция (Z-function) — это строковый алгоритм, который для каждой позиции i в строке вычисляет длину наибольшего общего префикса между i-подстрокой и всей исходной строкой. Префикс - подстрока, начинающаяся с первого символа исходной строки.

Пример:
Имеется строка S длины n. Воспользуемся Z-функцией и создадим массив Z, где Z[i] — это наибольшее число символов, начиная с позиции i, которые совпадают с префиксом строки S.

То есть, для каждой позиции i, Z[i] равно количеству символов, совпадающих с префиксом строки S, начиная с позиции i. Значение Z[i] может быть нулевым, если нет совпадающих символов.

### Алгоритм построения

1. Создаем массив Z с длиной, равной длине исходной строки. Каждый элемент массива Z будет хранить значение Z-функции для соответствующей позиции в строке.
2. Инициализируем два указателя, left и right, в начале строки. Указатель left указывает на начало текущей подстроки, для которого мы вычисляем Z-функцию, а указатель right указывает на конец этой подстроки.
3. Для каждой позиции i от 1 до n-1, где n - длина строки:
   - Если i находится в пределах текущей подстроки (i <= right), мы можем использовать уже вычисленные значения Z-функции для предыдущих позиций.
     - Если Z[i - left] < right - i + 1, то значение Z[i] будет равно Z[i - left], поскольку подстрока [i, right] полностью совпадает с подстрокой [left, right].
     - Если Z[i - left] >= right - i + 1, мы должны расширить текущий подстрок, чтобы найти новые совпадающие символы. Для этого мы увеличиваем right на 1 и сравниваем символы на позициях right и i.
     - Если символы совпадают, мы увеличиваем Z[i] на 1, поскольку мы нашли еще одно совпадение символов.
     - Если символы не совпадают, мы заканчиваем расширение текущего подстрока.
   - Если i находится за пределами текущего подстрока (i > right), мы не можем использовать предыдущие значения Z-функции и вычисляем значение Z[i] непосредственно путем сравнения символов.
4. Если right + 1 > n, значит мы достигли конца строки и вычисление Z-функции завершено.

В результате выполнения алгоритма у нас будет заполненный массив Z, где Z[i] содержит значение Z-функции для позиции i в исходной строке.

### Оценка времени выполнения

## π-функция

Перед рассмотрением π-функции нам понадобится дать определение суффиксу строки.

Суффикс строки - это последовательность символов, начиная с определенной позиции и до конца строки. Другими словами, суффикс представляет собой "хвост" строки, оставшийся после отбрасывания первых нескольких символов.

Например, суффиксы строки "banana":

- "banana" (суффикс, начинающийся с позиции 0)
- "nana" (суффикс, начинающийся с позиции 2)
- "na" (суффикс, начинающийся с позиции 4)

### Определение

Пи-функция - определенная на строке функция, которая для каждой позиции в строке возвращает длину наибольшего собственного суффикса, который также является префиксом этой строки.

### Алгоритм построения

### Оценка времени выполнения

(Z-function) определяет для каждой позиции i в строке длину наибольшего префикса, начинающегося в позиции i, который является также префиксом всей строки. Другими словами, Z-функция определяет наибольший общий префикс строки со всеми ее суффиксами, начиная с данной позиции.

Пи-функция (π-function), также известная как функция префикса, определяет для каждой позиции i в строке длину наибольшего собственного префикса строки, являющегося также ее суффиксом. Собственный префикс означает, что префикс не совпадает со всей строкой.

Обе эти функции широко используются в строковых алгоритмах, таких как поиск подстроки, сжатие строк, построение суффиксных массивов и других алгоритмах обработки строк. Они позволяют эффективно находить совпадения или шаблоны в строках и выполнять другие операции над ними.

Реализации алгоритмов для вычисления Z-функции и π-функции достаточно просты и могут быть легко найдены в различных источниках и библиотеках программирования.

# 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2+E). Улучшение алгоритма для разреженных графов за O(E\*logV)

## Опрееление алгоритма Дейксты

Алгоритм Дейкстры – это алгоритм на графах, используемый для нахождения кратчайшего пути от одной из вершин до всех остальных вершин взвешенного графа.

Условия работы алгоритма Дейкстры:

- отсутствие циклов отрицательного веса
- отсутствие отрицательных весов ребер

## Постановка задачи состоит в следующем

Условие: Дан взвешенный граф G с N вершинами и M ребрами. Задана стартовая вершина S.
Задача: Необходимо найти кратчайшие пути от вершины S до всех остальных вершин графа.

## Описание алгоритма за O(V^2+E)

1. Инициализируем все вершины графа значением "бесконечность", кроме начальной вершины, которой присваиваем значение 0.
2. Создаем пустое множество посещенных вершин.
3. На каждой итерации выбираем вершину с наименьшим текущим расстоянием из начальной вершины. Начально это будет сама начальная вершина.
4. Помечаем выбранную вершину как посещенную и обновляем расстояние до ее соседних вершин. Если новое расстояние до соседней вершины меньше текущего расстояния, то обновляем его.
5. Повторяем шаги 3 и 4 для всех оставшихся непосещенных вершин.
6. По завершении алгоритма для каждой вершины будет найдено кратчайшее расстояние от начальной вершины.

## Улучшение алгоритма для разреженных графов за O(E\*logV)

Улучшение достигается с помощью использования структуры данных, называемой минимальной кучей (в java это класс PriorityQueue). Каждая вершина - класс, в нем сохранены два параметра - значение вершины и текущее расстояние.

1. Инициализируем все вершины графа значением "бесконечность", кроме начальной вершины, которой присваиваем значение 0.
2. Создаем пустую минимальную кучу, которая принимает вершины графа.
3. Вставляем начальную вершину в приоритетную очередь с расстоянием 0.
4. Рассматриваем минимальную кучу. Пока она не пуста:
   - Извлекаем вершину с наименьшим текущим расстоянием из приоритетной очереди.
   - Помечаем извлеченную вершину как посещенную.
   - Для каждого соседа текущей вершины:
     - Если новое расстояние до соседа через текущую вершину меньше его текущего расстояния, обновляем его.
     - Вставляем соседа в приоритетную очередь с обновленным расстоянием.
5. По завершении алгоритма для каждой вершины будет найдено кратчайшее расстояние от начальной вершины.

### Почему улучшение работает с разреженными графом

// TODO разобраться с этим подпунктом. Объяснить, почему у нас выходит такое время

В алгоритме Дейкстры, без использования минимальной кучи, на каждой итерации выбирается вершина с наименьшим расстоянием из множества всех вершин. Время выбора такой вершины изначально зависит от количества вершин (V итераций \* V вершин = V\*\*2).

Минимальная куча позволяет хранить вершины и их текущие расстояния таким образом, что выбор вершины с наименьшим расстоянием происходит за время O(logV) (вспомним про просеивание вниз). Это обеспечивает значительное ускорение алгоритма для разреженных графов, где количество ребер (E) намного меньше количества вершин (V).

В плотных графах может возникнуть ситуация, когда количество ребер в графе составляет O(V^2). Тогда куча становится близкой к полной, и операции с ней могут занять дополнительное время, что может быть неэффективно в сравнении с предыдущим алгоритмом.

## Реализация алгоритма на Java

Создадим классы Edge и Node для реализации обоих алгоритмов

```java
    static class Edge {
        public int neighbor; // vertex соседа
        public int weight; // вес ребра


        public Edge(int neighbor, int weight) {
            this.neighbor = neighbor;
            this.weight = weight;
        }
}
```

```java
    static class Node implements Comparator<Node> {
        public int vertex; // значение вершины
        public int distance; // текущее расстояние

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        // Метод статического класса. Сравнивает две вершины по их расстояниям
        public int compare(Node node1, Node node2) {
            if (node1.distance < node2.distance) {
                return -1;
            }
            if (node1.distance > node2.distance) {
                return 1;
            }
            return 0;
        }
    }
```

Хранение взвешенного графа происходит с помощью списка смежности. Граф - словарь, где ключ - int vertex, а значение - массив всех ребер, исходящих из вершины ориентированного графа. Вес ребра между вершинами обозначается целым числом, а отсутствие ребра либо нулем, либо с помощью специального значения

```java
Map<Integer, List<Edge>> graph = new HashMap<Integer, List<Edge>>();
```

Пример графа:

```java
graph = {
    1: [new Edge(2,7), new Edge(3,1)],
    2: [new Edge(1,7), new Edge(4,3)],
    3: [new Edge(4,2), new Edge(6,1), new Edge(1,1)],
    4: [new Edge(2,3), new Edge(5,4), new Edge(3,2)],
    5: [new Edge(4,4), new Edge(7,5), new Edge(8,20)],
    6: [new Edge(3,1), new Edge(7,13), new Edge(9,9)],
    7: [new Edge(6,13), new Edge(9,1), new Edge(8,3), new Edge(5,5)],
    8: [new Edge(5,10), new Edge(7,3), new Edge(9,6)],
    9: [new Edge(6,9), new Edge(7,1), new Edge(8,6)]
}
```

# 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке

## Определение динамического программирования

Динамическое программирование — это метод решения задач, основанный на **разбиении исходной задачи на более мелкие подзадачи**, решение каждой из которых производится только один раз, после чего результаты **сохраняются для дальнейшего использования** при решении большей задачи.

Динамическое программирование часто используется для задач оптимизации, например, нахождения минимального пути или наибольшей подпоследовательности.

## Основные понятия

**Оптимальная подструктура** в динамическом программировании означает, что оптимальное **решение подзадач меньшего размера может быть использовано для решения исходной задачи**. В общем случае мы можем решить задачу, в которой присутствует оптимальная подструктура, проделывая следующие три шага.

1. Разбиение задачи на подзадачи меньшего размера.
2. Нахождение оптимального решения подзадач рекурсивно, проделывая такой же трёхшаговый алгоритм.
3. Использование полученного решения подзадач для конструирования решения исходной задачи.

В этом алгоритме решение задачи строится **путем рекурсивного разбиения ее на подзадачи и нахождения оптимальных решений для них**. Затем эти оптимальные решения сохраняются и используются для вычисления оптимального решения всей задачи.

Принцип оптимальности Беллмана является основной идеей динамического программирования. Он заключается в том, что **оптимальное решение задачи содержит в себе оптимальные решения ее подзадач**.
Более формально, принцип оптимальности Беллмана можно сформулировать следующим образом: Если задача может быть разбита на подзадачи, и оптимальное решение задачи можно выразить через оптимальные решения ее подзадач, то оптимальное решение всей задачи будет содержать в себе оптимальные решения подзадач.

В решении задач методами динамического программирования необходимо сохранять результаты вычислений для повторного использования. Этот процесс называется мемоизация. При использовании мемоизации результаты вычислений подзадач сохраняются в структуре данных (обычно в массиве или хеш-таблице), чтобы избежать повторных вычислений.

Итого, ключевые слова и понятия ДП: рекурсивное определение задач, принцип оптимальности Беллмана, оптимальные подструктуры, мемоизация

## Задача про кузнечика

Задача про кузнечика — это стандартный пример задачи, которая решается с помощью динамического программирования.

### Задача

найти количество способов, которыми кузнечик может добраться из точки 1 до точки N, прыгая только на 1 или 2 шага вперед.

### Решение

Создадим массив dp размером N+1, где dp[i] будет хранить количество способов, которыми кузнечик может добраться из точки 1 до точки i.

### Алгоритм

1. dp[0] равна нулю
2. Начальные значения dp[1] и dp[2] будут равны 1 и 2 соответственно - в первую он может прыгнуть только одним прыжком, во вторую с помощью двух одинарных прыжков и с помощью одного двойного
3. Затем мы будем заполнять массив dp с помощью цикла от 3 до N. Для каждого i мы будем находить сумму dp[i-1] и dp[i-2], так как кузнечик может добраться до точки i из точки i-1 или i-2. Таким образом, dp[i] будет равно количеству способов, которыми кузнечик может добраться до точки i.
4. В конце мы вернем значение dp[N], которое будет равно количеству способов, которыми кузнечик может добраться из точки 1 до точки N.

## Задача о черепашке

### Задача

Черепашка находится в левом верхнем углу сетки размером N x M и должна добраться до правого нижнего угла. Черепашка может двигаться только вниз или вправо. Каждая ячейка сетки имеет определенное значение, которое представляет стоимость прохождения черепашки через эту ячейку. Наша задача состоит в том, чтобы найти путь с минимальной стоимостью от начальной позиции до конечной позиции.

### Решение

Для решения этой задачи с использованием динамического программирования, мы можем создать дополнительную сетку размером N x M, где каждая ячейка будет содержать минимальную стоимость достижения этой ячейки из начальной позиции. Давайте назовем эту сетку dp.

### Алгоритм

1. Инициализируем первую строку и первый столбец сетки dp суммой стоимостей ячеек, по которым проходит черепашка.
2. Для каждой ячейки dp[i][j], где i>0 и j>0, вычисляем минимальную стоимость достижения этой ячейки, используя формулу:

```python
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
# dp[i-1][j] - движение влево
# dp[i][j-1] - движение вверх

# где grid[i][j] - это стоимость текущей ячейки
```

3. После прохода через всю сетку dp, значение dp[N-1][M-1] будет содержать минимальную стоимость достижения конечной позиции.
4. Таким образом, ответ на задачу будет равен dp[N-1][M-1].

# 5. Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы

## Определение задачи о рюкзаке

Задача о рюкзаке - это классическая задача комбинаторной оптимизации. У нас есть рюкзак определенной вместимости (пусть он задан максимальным весом), и у нас есть набор предметов, каждый из которых имеет свой вес и стоимость. Наша задача - выбрать определенный набор предметов, чтобы их суммарная стоимость была максимальной, при условии, что их суммарный вес не превышает вместимость рюкзака.

## Постановка задачи о рюкзаке

Дано: набор предметов с заданными весами, стоимостями и вместимость рюкзака.
Ограничения: каждый предмет может быть выбран только один раз (или 0 раз, то есть не выбран).
Цель: максимизировать суммарную стоимость выбранных предметов.

## Решение методом динамического программирования

Решение классической задачи о рюкзаке с помощью динамического программирования основывается на принципе **оптимальной подструктуры и повторных вычислениях**.

Алгоритм решения

1. Создаем двумерный массив dp размером (n+1) на (W+1), где n - количество предметов, W - вместимость рюкзака.

- Строки от 0 до n+1: Комбинация предметов, которые мы рассматриваем для упаковки в рюкзак. Индекс строки от 1 до n соответствует номеру предмета. Например, dp[1] будет соответствовать первому предмету, dp[2] - второму предмету и так далее.

Столбцы от 0 до W+1: Каждый столбец массива dp соответствует вместимости рюкзака для определенной вместимости. Например, dp[i][1] будет соответствовать вместимости рюкзака равной 1, dp[i][2] - вместимости 2 и так далее.

Таким образом, каждая ячейка dp[i][j] в массиве dp содержит максимальную стоимость, которую можно достичь с использованием предметов с индексами от 1 до i при вместимости рюкзака j.

2. Инициализируем первую строку dp нулями, так как при отсутствии предметов стоимость будет равна нулю.
3. Заполняем массив dp построчно и поэлементно с использованием рекуррентного соотношения.
   Для каждого предмета i (от 1 до n) и вместимости рюкзака j (от 1 до W) выполняем следующие шаги:

   - Если вес предмета i больше текущей вместимости j, то пропускаем его и оставляем значение dp[i][j] равным значению dp[i-1][j].
   - Если вес предмета i меньше или равен текущей вместимости j, то выбираем максимум из двух вариантов:
   - Не включать предмет i: dp[i][j] = dp[i-1][j].
   - Включить предмет i: dp[i][j] = стоимость предмета i + dp[i-1][j-вес предмета i], где второе слагаемое - это стоимость груза до добавление нового веса.
     Значение dp[i][j] будет равно максимальной стоимости из этих двух вариантов.

4. В итоге, максимальная стоимость, которую можно получить, будет находиться в ячейке dp[n][W].
5. Чтобы восстановить выбранный набор предметов, начинаем с ячейки dp[n][W] и движемся назад по массиву dp. Если значение dp[i][j] отличается от dp[i-1][j], значит предмет i был включен в рюкзак. Переходим к ячейке dp[i-1][j-вес предмета i] и продолжаем обратное движение до ячейки dp[1][1], восстанавливая выбранные предметы.

## Оценка времени работы

Временная сложность решения классической задачи о рюкзаке с помощью динамического программирования зависит от количества предметов n и вместимости рюкзака W.

Время выполнения программы составляет O(n \* W). Это связано с двойным циклом, с помощью которого мы проходимся по созданной матрице dp. Во время цикла мы рассматриваем каждый предмет и каждую возможную вместимость рюкзака.

# 6. Задача поиска наибольшей возрастающей подпоследовательности в массиве. Решение за O(N^2) методом динамического программирования. Решение за O(NlogN) методом динамического программирования

## Формулировка задачи

Задача поиска наибольшей возрастающей подпоследовательности в числовом массиве заключается в нахождении подпоследовательности элементов, которая строго возрастает и имеет максимальную длину.

Дано: массив arr
Задача: найти длину наибольшей возрастающей подпоследовательности

## Алгоритм решения задачи за O(N^2)

1. Создаем массив dp длины N, где N - количество элементов в исходном массиве. Инициализируем все элементы dp значением 1, так как каждый элемент сам по себе является возрастающей подпоследовательностью длины 1.
2. Проходимся по массиву элементов и для каждого элемента arr[i], начиная с индекса 1, сравниваем его со всеми предыдущими элементами arr[j], где j меньше i.
3. Если arr[i] больше arr[j], то значит мы можем продолжить предыдущую возрастающую подпоследовательность, добавив arr[i] к ней.
   Мы обновляем значение dp[i] путем выбора максимальной длины из dp[j] + 1 (длина предыдущей подпоследовательности, к которой мы добавляем текущий элемент) и текущего значения dp[i].

```python
dp[i] = max(dp[i], dp[j] + 1)
```

Это означает, что мы увеличиваем значение dp[i] только в случае, если добавление arr[i] к возрастающей подпоследовательности, заканчивающейся на arr[j], даст нам более длинную подпоследовательность.

4. Повторяем шаги 2-3 для всех элементов массива arr.
5. Находим максимальное значение в массиве dp, которое будет представлять длину наибольшей возрастающей подпоследовательности.

### Пример

0. arr = [3, 1, 5, 2, 4, 6]. dp = [1, 1, 1, 1, 1, 1]
1. arr[0] = 3. Не имеем предыдущих элементов, поэтому dp[1] остается 1
2. Для элемента arr[1] = 1.
   - arr[1]>arr[0] (1>3) - условие не выполняется, поэтому dp[1] остается 1

dp = [1, 1, 1, 1, 1, 1]

3. arr[2] = 5, сравниваем с предыдущими элементами:

- arr[2] > arr[0] (5 > 3), поэтому обновляем dp[2] = max(dp[2], dp[1]+1) = max(1, 1+1) = 2
- arr[2] > arr[1] (5 > 1), поэтому обновляем dp[2] = max(dp[2], dp[1] + 1) = max(2, 1 + 1) = 2.

dp = [1, 1, 2, 1, 1, 1]

4. arr[3] = 2, сравниваем с предыдущими элементами:
   - arr[3] > arr[0] (2 > 3) не выполняется, поэтому оставляем dp[3] = 1
   - arr[3] > arr[1] (2 > 1), поэтому обновляем dp[3] = max(dp[3], dp[1] + 1) = max(1, 1 + 1) = 2.
   - arr[3] > arr[2] (2 > 5), условие не выполняется, оставляем dp[3] = 2.

dp = [1, 1, 2, 2, 1, 1]

5. arr[4] = 4, сравниваем с предыдущими элементами:

   - arr[4] > arr[0] (4 > 3), поэтому обновляем dp[4] = max(dp[4], dp[0]+1) = max(1, 1+1) = 2
   - arr[4] > arr[1] (4 > 1), поэтому обновляем dp[4] = max(dp[4], dp[1] + 1) = max(2, 1 + 1) = 2.
   - arr[4] > arr[2] (4 > 5), условие не выполняется, оставляем dp[4] = 2.
   - arr[4] > arr[3] (4 > 2), поэтому обновляем dp[4] = max(dp[4], dp[3] + 1) = max(2, 2 + 1) = 3.

dp = [1, 1, 2, 2, 3, 1]

6. Для элемента arr[5] = 6, сравниваем с предыдущими элементами:
   - arr[5] > arr[0] (6 > 3), поэтому обновляем dp[5] = max(dp[5], dp[0] + 1) = max(1, 1 + 1) = 2.
   - arr[5] > arr[1] (6 > 1), поэтому обновляем dp[5] = max(dp[5], dp[1] + 1) = max(2, 1 + 1) = 2.
   - arr[5] > arr[2] (6 > 5), поэтому обновляем dp[5] = max(dp[5], dp[2] + 1) = max(2, 2 + 1) = 3.
   - arr[5] > arr[3] (6 > 2), поэтому обновляем dp[5] = max(dp[5], dp[3] + 1) = max(3, 2 + 1) = 3.
   - arr[5] > arr[4] (6 > 4), поэтому обновляем dp[5] = max(dp[5], dp[4] + 1) = max(3, 3 + 1) = 4.

dp = [1, 1, 2, 2, 3, 4]

## Алгоритм решения задачи за O(NlogN)

1. Создаем пустой массив tails, который будет хранить нарастающие подпоследовательности. Устанавливаем его первый элемент равным первому элементу исходного массива.
2. Проходим по остальным элементам исходного массива, начиная со второго элемента.
3. Для каждого элемента arr[i] выполняем бинарный поиск в массиве tails , чтобы найти самую правую позицию, на которую можно вставить arr[i] так, чтобы поддерживать возрастающую последовательность.
   - Если найденная позиция равна длине массива tails, то добавляем arr[i] в конец tails, так как он может продлить наибольшую возрастающую подпоследовательность.
   - В противном случае заменяем элемент в найденной позиции на arr[i], так как это обновление приводит к созданию новой возрастающей подпоследовательности, более длинной или равной предыдущей.
4. В конце процесса длина массива tails будет представлять длину наибольшей возрастающей подпоследовательности.

### Пример

0. arr = [3, 1, 5, 2, 4, 6]
1. Инициализируем массив tails с первым элементом arr[0]: tails = [3]
2. Рассматриваем arr[1] = 1:

   - Выполняем бинарный поиск в массиве tails. Так как 1 меньше элемента 3, найденная позиция равна 0.
   - Заменяем элемент в найденной позиции на 1.

tails = [1].

3.  Рассматриваем arr[2] = 5:
    - Выполняем бинарный поиск в массиве tails. Так как 5 больше всех элементов в tails, найденная позиция равна длине массива tails (1).
    - Добавляем 5 в конец массива tails.

tails = [1, 5].

4. Рассматриваем arr[3] = 2:
   - Выполняем бинарный поиск в массиве tails. Так как 2 меньше элемента 5, найденная позиция равна 1.
   - Заменяем элемент в найденной позиции на 2.

tails = [1, 2].

5. Рассматриваем arr[4] = 4:
   - Выполняем бинарный поиск в массиве tails. Так как 4 больше всех элементов в tails, найденная позиция равна длине массива tails (2).
   - Добавляем 4 в конец массива tails.

tails = [1, 2, 4].

6. Рассматриваем arr[5] = 6:

- Выполняем бинарный поиск в массиве tails. Так как 6 больше всех элементов в tails, найденная позиция равна длине массива tails (3).
- Добавляем 6 в конец массива tails

tails = [1, 2, 4, 6].

7. Длина наибольшей возрастающей подпоследовательности равна длине массива tails, то есть 4.
