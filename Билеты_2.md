# 1. Хеширование. Полиномиальная функция. Алгоритм Рабина-Карпа. Оценка времени выполнения функции

## Хеширование

### Определение хеширования

Хеширование - метод преобразования входных данных произвольной длины в выходные данные фиксированной длины с помощью хеш-функции. Для выполнения преобразования используется хеш-функция.

Хеш-функция берет входные данные и вычисляет выходные данные фиксированной длины, которые называются хеш-значением.

### Свойства хеш-значений и хеш-функций

- Равномерное распределение значений: хеш-функция стремится равномерно распределить хеш-значения по всем возможным выходным значениям. Это гарантирует минимальное количество коллизий и минимальную зависимость между входными данными и их хеш-значениями. Последнее означает, что небольшое изменение во входных данных должно вызывать значительное изменение в соответствующем хеш-значении.
- Уникальность: Каждый объект должен иметь уникальное хеш-значение. Это означает, что для разных объектов хеш-значения должны быть различными. Однако, возможны коллизии, когда двум разным объектам соответствует одно и то же хеш-значение.
- Детерминированность: Для одного и того же объекта хеш-функция всегда должна возвращать одно и то же хеш-значение.
- Эффективность: Вычисление хеш-значения должно занимать небольшое время в сравнении с общей сложность операций над объектами.

## Полиномиальная функция

Полиномиальная функция - математическая функция, которая задается выражением вида:

f(x) = aₙxⁿ + aₙ₋₁xⁿ⁻¹ + ... + a₂x² + a₁x + a₀,

где a₀, a₁, ..., aₙ - коэффициенты полинома, x - переменная, а n - степень полинома.

Степень полинома определяется максимальной степенью переменной в выражении. Например, в полиноме f(x) = 3x³ + 2x² + x + 1 степень полинома равна 3.

### Свойства полинома

- Коэффициенты: Коэффициенты полинома могут быть любыми числами, включая целые, дробные и комплексные числа. Они определяют вклад каждого члена полинома в его общую форму.
- Значения и корни: Полиномиальные функции могут быть использованы для нахождения значений функции при заданных значениях переменной. Также они используются для нахождения корней полинома, то есть значений переменной, при которых функция равна нулю.
- Приближение функций: Полиномиальные функции могут быть использованы для приближения сложных функций с помощью более простых полиномов.

### Теорема о корнях полинома

Если полином P(x) имеет степень n, то он имеет ровно n корней (учитывая кратность) в комплексной области.

### Полиномиальный хеш

Полиномиальный хеш используется в алгоритме Рабин-Карпа

Полиномиальный хеш - это метод хеширования, который использует полиномиальную функцию для преобразования последовательности символов в числовое значение.

Принцип работы полиномиального хеша:

1. Каждому символу в алфавите назначается **уникальное** числовое значение.
2. Полиномиальная функция использует эти числовые значения символов для вычисления хеш-значения для каждой подстроки. Чаще всего используется формула:

```
hash = (s[0] * p^(n-1)) + (s[1] * p^(n-2)) + ... + (s[n-1] * p^0),

где s[i] - числовое значение символа на позиции i, p - выбранное простое число (база полинома), n - длина последовательности символов.
```

Важно отметить, что степенные функции p^(n-1), p^(n-2), ... обеспечивают различные веса для каждого символа в последовательности. Это позволяет получить уникальное хеш-значение для разных комбинаций одинаковых символов последовательностей символов. 3. Вычисленное хеш-значение используется для сравнения с хеш-значением подстрок текста. Если хеш-значения совпадают, то с большой вероятностью подстрока и искомая строка также совпадают.

Преимущество использования полиномиального хеша в сравнении подстрок заключается в том, что установление несоответствия подстрок происходит за (O(1)) вместо (O(m)) для обычного сравнения. Это делает алгоритм Рабин-Карпа эффективным для поиска подстрок в тексте.

## Алгоритм Рабина-Карпа

### Определение алгоритма Рабина-Карпа

Рабин-Карп - алгоритм поиска строки, который ищет подстроку в тексте, используя хеширование.

Алгоритм Рабина-Карпа эффективен при поиске образца в тексте, особенно если искомая подстрока длинная и общая для нескольких текстовых блоков. Он может быть использован в различных приложениях, таких как поиск по тексту или фильтрация спама.

### Описание алгоритма Рабина-Карпа

1. С помощью полиномиальной хеш функции вычисляем хеш-значение подстроки, которую мы хотим найти. Вычисляем хеш-значения первой подстроки в целевой строке.
2. Затем алгоритм сравнивает хеш-значения нашей подстроки и текущей подстроки в целевой строке. Если хеш-значения совпадают, то алгоритм производит точное сравнение символов для проверки наличия полного совпадения.
3. Точное сравнение производится из-за коллизии хеш-значений, когда разные подстроки имеют одинаковые хеш-значения. Алгоритм проводит дополнительную проверку символов для исключения ложных срабатываний.
4. Если совпадение не найдено, **окно сравнения** сдвигается вправо на один символ, и новое хеш-значение вычисляется для следующей подстроки в целевой строке. Процесс повторяется до достижения конца строки или обнаружения совпадения.
5. Если полное совпадение найдено, алгоритм возвращает позицию первого символа подстроки в целевой строке.
6. При достижении конца строки алгоритм заканчивает работу.

### Время выполнения алгоритма

Существуют следующие случаи: худший, средний и лучший.

Худший случай O(nm): В случае, когда все символы текста и подстроки совпадают, алгоритм будет иметь худший случай временной сложности O(nm). Это происходит, когда все символы подстроки должны быть сравнены со всеми символами текста.

Средний случай O(n): В большинстве случаев, когда текст и подстрока не совпадают полностью, алгоритм имеет среднюю временную сложность O(n + m). Это связано с тем, что в большинстве случаев можно быстро отсеять несовпадающие подстроки с помощью сравнения хеш-значений.

Лучший случай O(n): В наилучшем случае, когда подстрока не найдена в тексте, алгоритм может иметь лучшую временную сложность O(n). Это происходит, когда сравнение хеш-значений подстроки и текста не дает совпадения, и алгоритм проходит по всем символам текста только один раз.

// TODO: добавить код алгоритма в Билеты_Код_2.md

# 2. Z-функция. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения

Z-функция и π-функция являются алгоритмическими конструкциями, используемыми в строковых алгоритмах для эффективного нахождения подстрок в строке.

### Z-функция

### Определение Z-функции

Z-функция (Z-function) — это строковый алгоритм, который для каждой позиции i в строке вычисляет длину наибольшего общего префикса между i-подстрокой и всей исходной строкой. Префикс - подстрока, начинающаяся с первого символа исходной строки.

Пример:
Имеется строка S длины n. Воспользуемся Z-функцией и создадим массив Z, где Z[i] — это наибольшее число символов, начиная с позиции i, которые совпадают с префиксом строки S.

То есть, для каждой позиции i, Z[i] равно количеству символов, совпадающих с префиксом строки S, начиная с позиции i. Значение Z[i] может быть нулевым, если нет совпадающих символов.

### Алгоритм построения

1. Создаем массив Z с длиной, равной длине исходной строки. Каждый элемент массива Z будет хранить значение Z-функции для соответствующей позиции в строке.
2. Инициализируем два указателя, left и right, в начале строки. Указатель left указывает на начало текущей подстроки, для которого мы вычисляем Z-функцию, а указатель right указывает на конец этой подстроки.
3. Для каждой позиции i от 1 до n-1, где n - длина строки:
   - Если i находится в пределах текущей подстроки (i <= right), мы можем использовать уже вычисленные значения Z-функции для предыдущих позиций.
     - Если Z[i - left] < right - i + 1, то значение Z[i] будет равно Z[i - left], поскольку подстрока [i, right] полностью совпадает с подстрокой [left, right].
     - Если Z[i - left] >= right - i + 1, мы должны расширить текущий подстрок, чтобы найти новые совпадающие символы. Для этого мы увеличиваем right на 1 и сравниваем символы на позициях right и i.
     - Если символы совпадают, мы увеличиваем Z[i] на 1, поскольку мы нашли еще одно совпадение символов.
     - Если символы не совпадают, мы заканчиваем расширение текущего подстрока.
   - Если i находится за пределами текущего подстрока (i > right), мы не можем использовать предыдущие значения Z-функции и вычисляем значение Z[i] непосредственно путем сравнения символов.
4. Если right + 1 > n, значит мы достигли конца строки и вычисление Z-функции завершено.

В результате выполнения алгоритма у нас будет заполненный массив Z, где Z[i] содержит значение Z-функции для позиции i в исходной строке.

### Оценка времени выполнения

## π-функция

Перед рассмотрением π-функции нам понадобится дать определение суффиксу строки.

Суффикс строки - это последовательность символов, начиная с определенной позиции и до конца строки. Другими словами, суффикс представляет собой "хвост" строки, оставшийся после отбрасывания первых нескольких символов.

Например, суффиксы строки "banana":

- "banana" (суффикс, начинающийся с позиции 0)
- "nana" (суффикс, начинающийся с позиции 2)
- "na" (суффикс, начинающийся с позиции 4)

### Определение

Пи-функция - определенная на строке функция, которая для каждой позиции в строке возвращает длину наибольшего собственного суффикса, который также является префиксом этой строки.

### Алгоритм построения

### Оценка времени выполнения

(Z-function) определяет для каждой позиции i в строке длину наибольшего префикса, начинающегося в позиции i, который является также префиксом всей строки. Другими словами, Z-функция определяет наибольший общий префикс строки со всеми ее суффиксами, начиная с данной позиции.

Пи-функция (π-function), также известная как функция префикса, определяет для каждой позиции i в строке длину наибольшего собственного префикса строки, являющегося также ее суффиксом. Собственный префикс означает, что префикс не совпадает со всей строкой.

Обе эти функции широко используются в строковых алгоритмах, таких как поиск подстроки, сжатие строк, построение суффиксных массивов и других алгоритмах обработки строк. Они позволяют эффективно находить совпадения или шаблоны в строках и выполнять другие операции над ними.

Реализации алгоритмов для вычисления Z-функции и π-функции достаточно просты и могут быть легко найдены в различных источниках и библиотеках программирования.

# 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2+E). Улучшение алгоритма для разреженных графов за O(E\*logV)

## Опрееление алгоритма Дейксты

Алгоритм Дейкстры – это алгоритм на графах, используемый для нахождения кратчайшего пути от одной из вершин до всех остальных вершин взвешенного графа.

Условия работы алгоритма Дейкстры:

- отсутствие циклов отрицательного веса
- отсутствие отрицательных весов ребер

## Постановка задачи состоит в следующем

Условие: Дан взвешенный граф G с N вершинами и M ребрами. Задана стартовая вершина S.
Задача: Необходимо найти кратчайшие пути от вершины S до всех остальных вершин графа.

## Описание алгоритма за O(V^2+E)

1. Инициализируем все вершины графа значением "бесконечность", кроме начальной вершины, которой присваиваем значение 0.
2. Создаем пустое множество посещенных вершин.
3. На каждой итерации выбираем вершину с наименьшим текущим расстоянием из начальной вершины. Начально это будет сама начальная вершина.
4. Помечаем выбранную вершину как посещенную и обновляем расстояние до ее соседних вершин. Если новое расстояние до соседней вершины меньше текущего расстояния, то обновляем его.
5. Повторяем шаги 3 и 4 для всех оставшихся непосещенных вершин.
6. По завершении алгоритма для каждой вершины будет найдено кратчайшее расстояние от начальной вершины.

## Улучшение алгоритма для разреженных графов за O(E\*logV)

Улучшение достигается с помощью использования структуры данных, называемой минимальной кучей (в java это класс PriorityQueue). Каждая вершина - класс, в нем сохранены два параметра - значение вершины и текущее расстояние.

1. Инициализируем все вершины графа значением "бесконечность", кроме начальной вершины, которой присваиваем значение 0.
2. Создаем пустую минимальную кучу, которая принимает вершины графа.
3. Вставляем начальную вершину в приоритетную очередь с расстоянием 0.
4. Рассматриваем минимальную кучу. Пока она не пуста:
   - Извлекаем вершину с наименьшим текущим расстоянием из приоритетной очереди.
   - Помечаем извлеченную вершину как посещенную.
   - Для каждого соседа текущей вершины:
     - Если новое расстояние до соседа через текущую вершину меньше его текущего расстояния, обновляем его.
     - Вставляем соседа в приоритетную очередь с обновленным расстоянием.
5. По завершении алгоритма для каждой вершины будет найдено кратчайшее расстояние от начальной вершины.

### Почему улучшение работает с разреженными графом

// TODO разобраться с этим подпунктом. Объяснить, почему у нас выходит такое время
В алгоритме Дейкстры, без использования минимальной кучи, на каждой итерации выбирается вершина с наименьшим расстоянием из множества всех вершин. Время выбора такой вершины изначально зависит от количества вершин (V).

Минимальная куча позволяет хранить вершины и их текущие расстояния таким образом, что выбор вершины с наименьшим расстоянием происходит за время O(logV). Это обеспечивает значительное ускорение алгоритма для разреженных графов, где количество ребер (E) намного меньше количества вершин (V).

В плотных графах может возникнуть ситуациях, когда количество ребер в графе составляет O(V^2). Тогда куча становится близкой к полной, и тогда операции с ней могут занять дополнительное время, что может быть неэффективно в сравнии с предыдущим алгоритмом.

## Реализация алгоритма на Java

Создадим классы Edge и Node для реализации обоих алгоритмов

```java
    static class Edge {
        public int neighbor; // vertex соседа
        public int weight; // вес ребра


        public Edge(int neighbor, int weight) {
            this.neighbor = neighbor;
            this.weight = weight;
        }
}
```

```java
    static class Node implements Comparator<Node> {
        public int vertex; // значение вершины
        public int distance; // текущее расстояние

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        // Метод статического класса. Сравнивает две вершины по их расстояниям
        public int compare(Node node1, Node node2) {
            if (node1.distance < node2.distance) {
                return -1;
            }
            if (node1.distance > node2.distance) {
                return 1;
            }
            return 0;
        }
    }
```

Хранение взвешенного графа происходит с помощью списка смежности. Граф - словарь, где ключ - int vertex, а значение - массив всех ребер, исходящих из вершины ориентированного графа. Вес ребра между вершинами обозначается целым числом, а отсутствие ребра либо нулем, либо с помощью специального значения

```java
Map<Integer, List<Edge>> graph = new HashMap<Integer, List<Edge>>();
```

Пример графа:

```java
graph = {
    1: [new Edge(2,7), new Edge(3,1)],
    2: [new Edge(1,7), new Edge(4,3)],
    3: [new Edge(4,2), new Edge(6,1), new Edge(1,1)],
    4: [new Edge(2,3), new Edge(5,4), new Edge(3,2)],
    5: [new Edge(4,4), new Edge(7,5), new Edge(8,20)],
    6: [new Edge(3,1), new Edge(7,13), new Edge(9,9)],
    7: [new Edge(6,13), new Edge(9,1), new Edge(8,3), new Edge(5,5)],
    8: [new Edge(5,10), new Edge(7,3), new Edge(9,6)],
    9: [new Edge(6,9), new Edge(7,1), new Edge(8,6)]
}
```
