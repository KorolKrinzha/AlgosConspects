# 1. Хеширование. Полиномиальная функция. Алгоритм Рабина-Карпа. Оценка времени выполнения функции

## Хеширование

### Определение хеширования

Хеширование - метод преобразования входных данных произвольной длины в выходные данные фиксированной длины с помощью хеш-функции. Для выполнения преобразования используется хеш-функция.

Хеш-функция берет входные данные и вычисляет выходные данные фиксированной длины, которые называются хеш-значением.

### Свойства хеш-значений и хеш-функций

- Равномерное распределение значений: хеш-функция стремится равномерно распределить хеш-значения по всем возможным выходным значениям. Это гарантирует минимальное количество коллизий и минимальную зависимость между входными данными и их хеш-значениями. Последнее означает, что небольшое изменение во входных данных должно вызывать значительное изменение в соответствующем хеш-значении.
- Уникальность: Каждый объект должен иметь уникальное хеш-значение. Это означает, что для разных объектов хеш-значения должны быть различными. Однако, возможны коллизии, когда двум разным объектам соответствует одно и то же хеш-значение.
- Детерминированность: Для одного и того же объекта хеш-функция всегда должна возвращать одно и то же хеш-значение.
- Эффективность: Вычисление хеш-значения должно занимать небольшое время в сравнении с общей сложность операций над объектами.

## Полиномиальная функция

Полиномиальная функция - математическая функция, которая задается выражением вида:

f(x) = aₙxⁿ + aₙ₋₁xⁿ⁻¹ + ... + a₂x² + a₁x + a₀,

где a₀, a₁, ..., aₙ - коэффициенты полинома, x - переменная, а n - степень полинома.

Степень полинома определяется максимальной степенью переменной в выражении. Например, в полиноме f(x) = 3x³ + 2x² + x + 1 степень полинома равна 3.

### Свойства полинома

- Коэффициенты: Коэффициенты полинома могут быть любыми числами, включая целые, дробные и комплексные числа. Они определяют вклад каждого члена полинома в его общую форму.
- Значения и корни: Полиномиальные функции могут быть использованы для нахождения значений функции при заданных значениях переменной. Также они используются для нахождения корней полинома, то есть значений переменной, при которых функция равна нулю.
- Приближение функций: Полиномиальные функции могут быть использованы для приближения сложных функций с помощью более простых полиномов.

### Теорема о корнях полинома

Если полином P(x) имеет степень n, то он имеет ровно n корней (учитывая кратность) в комплексной области.

### Полиномиальный хеш

Полиномиальный хеш используется в алгоритме Рабин-Карпа

Полиномиальный хеш - это метод хеширования, который использует полиномиальную функцию для преобразования последовательности символов в числовое значение.

Принцип работы полиномиального хеша:

1. Каждому символу в алфавите назначается **уникальное** числовое значение.
2. Полиномиальная функция использует эти числовые значения символов для вычисления хеш-значения для каждой подстроки. Чаще всего используется формула:

```
hash = (s[0] * p^(n-1)) + (s[1] * p^(n-2)) + ... + (s[n-1] * p^0),

где s[i] - числовое значение символа на позиции i, p - выбранное простое число (база полинома), n - длина последовательности символов.
```

Важно отметить, что степенные функции p^(n-1), p^(n-2), ... обеспечивают различные веса для каждого символа в последовательности. Это позволяет получить уникальное хеш-значение для разных комбинаций одинаковых символов последовательностей символов. 3. Вычисленное хеш-значение используется для сравнения с хеш-значением подстрок текста. Если хеш-значения совпадают, то с большой вероятностью подстрока и искомая строка также совпадают.

Преимущество использования полиномиального хеша в сравнении подстрок заключается в том, что установление несоответствия подстрок происходит за (O(1)) вместо (O(m)) для обычного сравнения. Это делает алгоритм Рабин-Карпа эффективным для поиска подстрок в тексте.

## Алгоритм Рабина-Карпа

### Определение алгоритма Рабина-Карпа

Рабин-Карп - алгоритм поиска строки, который ищет подстроку в тексте, используя хеширование.

Алгоритм Рабина-Карпа эффективен при поиске образца в тексте, особенно если искомая подстрока длинная и общая для нескольких текстовых блоков. Он может быть использован в различных приложениях, таких как поиск по тексту или фильтрация спама.

### Описание алгоритма Рабина-Карпа

1. С помощью полиномиальной хеш функции вычисляем хеш-значение подстроки, которую мы хотим найти. Вычисляем хеш-значения первой подстроки в целевой строке.
2. Затем алгоритм сравнивает хеш-значения нашей подстроки и текущей подстроки в целевой строке. Если хеш-значения совпадают, то алгоритм производит точное сравнение символов для проверки наличия полного совпадения.
3. Точное сравнение производится из-за коллизии хеш-значений, когда разные подстроки имеют одинаковые хеш-значения. Алгоритм проводит дополнительную проверку символов для исключения ложных срабатываний.
4. Если совпадение не найдено, **окно сравнения** сдвигается вправо на один символ, и новое хеш-значение вычисляется для следующей подстроки в целевой строке. Процесс повторяется до достижения конца строки или обнаружения совпадения.
5. Если полное совпадение найдено, алгоритм возвращает позицию первого символа подстроки в целевой строке.
6. При достижении конца строки алгоритм заканчивает работу.

### Время выполнения алгоритма

Существуют следующие случаи: худший, средний и лучший.

Худший случай O(nm): В случае, когда все символы текста и подстроки совпадают, алгоритм будет иметь худший случай временной сложности O(nm). Это происходит, когда все символы подстроки должны быть сравнены со всеми символами текста.

Средний случай O(n): В большинстве случаев, когда текст и подстрока не совпадают полностью, алгоритм имеет среднюю временную сложность O(n + m). Это связано с тем, что в большинстве случаев можно быстро отсеять несовпадающие подстроки с помощью сравнения хеш-значений.

Лучший случай O(n): В наилучшем случае, когда подстрока не найдена в тексте, алгоритм может иметь лучшую временную сложность O(n). Это происходит, когда сравнение хеш-значений подстроки и текста не дает совпадения, и алгоритм проходит по всем символам текста только один раз.

// TODO: добавить код алгоритма в Билеты_Код_2.md

# 2. Z-функция. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения

Z-функция и π-функция являются алгоритмическими конструкциями, используемыми в строковых алгоритмах для эффективного нахождения подстрок в строке.

### Z-функция

### Определение Z-функции

Z-функция (Z-function) — это строковый алгоритм, который для каждой позиции i в строке вычисляет длину наибольшего общего префикса между i-подстрокой и всей исходной строкой. Префикс - подстрока, начинающаяся с первого символа исходной строки.

Пример:
Имеется строка S длины n. Воспользуемся Z-функцией и создадим массив Z, где Z[i] — это наибольшее число символов, начиная с позиции i, которые совпадают с префиксом строки S.

То есть, для каждой позиции i, Z[i] равно количеству символов, совпадающих с префиксом строки S, начиная с позиции i. Значение Z[i] может быть нулевым, если нет совпадающих символов.

### Алгоритм построения

1. Создаем массив Z с длиной, равной длине исходной строки. Каждый элемент массива Z будет хранить значение Z-функции для соответствующей позиции в строке.
2. Инициализируем два указателя, left и right, в начале строки. Указатель left указывает на начало текущей подстроки, для которого мы вычисляем Z-функцию, а указатель right указывает на конец этой подстроки.
3. Для каждой позиции i от 1 до n-1, где n - длина строки:
   - Если i находится в пределах текущей подстроки (i <= right), мы можем использовать уже вычисленные значения Z-функции для предыдущих позиций.
     - Если Z[i - left] < right - i + 1, то значение Z[i] будет равно Z[i - left], поскольку подстрока [i, right] полностью совпадает с подстрокой [left, right].
     - Если Z[i - left] >= right - i + 1, мы должны расширить текущий подстрок, чтобы найти новые совпадающие символы. Для этого мы увеличиваем right на 1 и сравниваем символы на позициях right и i.
     - Если символы совпадают, мы увеличиваем Z[i] на 1, поскольку мы нашли еще одно совпадение символов.
     - Если символы не совпадают, мы заканчиваем расширение текущего подстрока.
   - Если i находится за пределами текущего подстрока (i > right), мы не можем использовать предыдущие значения Z-функции и вычисляем значение Z[i] непосредственно путем сравнения символов.
4. Если right + 1 > n, значит мы достигли конца строки и вычисление Z-функции завершено.

В результате выполнения алгоритма у нас будет заполненный массив Z, где Z[i] содержит значение Z-функции для позиции i в исходной строке.

### Оценка времени выполнения

## π-функция

Перед рассмотрением π-функции нам понадобится дать определение суффиксу строки.

Суффикс строки - это последовательность символов, начиная с определенной позиции и до конца строки. Другими словами, суффикс представляет собой "хвост" строки, оставшийся после отбрасывания первых нескольких символов.

Например, суффиксы строки "banana":

- "banana" (суффикс, начинающийся с позиции 0)
- "nana" (суффикс, начинающийся с позиции 2)
- "na" (суффикс, начинающийся с позиции 4)

### Определение

Пи-функция - определенная на строке функция, которая для каждой позиции в строке возвращает длину наибольшего собственного суффикса, который также является префиксом этой строки.

### Алгоритм построения

### Оценка времени выполнения

(Z-function) определяет для каждой позиции i в строке длину наибольшего префикса, начинающегося в позиции i, который является также префиксом всей строки. Другими словами, Z-функция определяет наибольший общий префикс строки со всеми ее суффиксами, начиная с данной позиции.

Пи-функция (π-function), также известная как функция префикса, определяет для каждой позиции i в строке длину наибольшего собственного префикса строки, являющегося также ее суффиксом. Собственный префикс означает, что префикс не совпадает со всей строкой.

Обе эти функции широко используются в строковых алгоритмах, таких как поиск подстроки, сжатие строк, построение суффиксных массивов и других алгоритмах обработки строк. Они позволяют эффективно находить совпадения или шаблоны в строках и выполнять другие операции над ними.

Реализации алгоритмов для вычисления Z-функции и π-функции достаточно просты и могут быть легко найдены в различных источниках и библиотеках программирования.

# 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2+E). Улучшение алгоритма для разреженных графов за O(E\*logV)

## Определение алгоритма Дейксты

Алгоритм Дейкстры – это алгоритм на графах, используемый для нахождения кратчайшего пути от одной из вершин до всех остальных вершин взвешенного графа.

## Условия работы алгоритма Дейкстры

- отсутствие циклов отрицательного веса
- отсутствие отрицательных весов ребер

## Постановка задачи состоит в следующем

Условие: Дан взвешенный граф G с N вершинами и M ребрами. Задана стартовая вершина S.
Задача: Необходимо найти кратчайшие пути от вершины S до всех остальных вершин графа.

## Описание алгоритма за O(V^2+E)

1. Инициализируем все вершины графа значением "бесконечность", кроме начальной вершины, которой присваиваем значение 0.
2. Создаем пустое множество посещенных вершин.
3. На каждой итерации выбираем вершину с наименьшим текущим расстоянием из начальной вершины. Начально это будет сама начальная вершина.
4. Помечаем выбранную вершину как посещенную и обновляем расстояние до ее соседних вершин. Если новое расстояние до соседней вершины меньше текущего расстояния, то обновляем его.
5. Повторяем шаги 3 и 4 для всех оставшихся непосещенных вершин.
6. По завершении алгоритма для каждой вершины будет найдено кратчайшее расстояние от начальной вершины.

## Улучшение алгоритма для разреженных графов за O(E\*logV)

Улучшение достигается с помощью использования структуры данных, называемой минимальной кучей (в java это класс PriorityQueue). Каждая вершина - класс, в нем сохранены два параметра - значение вершины и текущее расстояние.

1. Инициализируем все вершины графа значением "бесконечность", кроме начальной вершины, которой присваиваем значение 0.
2. Создаем пустую минимальную кучу, которая принимает вершины графа.
3. Вставляем начальную вершину в приоритетную очередь с расстоянием 0.
4. Рассматриваем минимальную кучу. Пока она не пуста:
   - Извлекаем вершину с наименьшим текущим расстоянием из приоритетной очереди.
   - Помечаем извлеченную вершину как посещенную.
   - Для каждого соседа текущей вершины:
     - Если новое расстояние до соседа через текущую вершину меньше его текущего расстояния, обновляем его.
     - Вставляем соседа в приоритетную очередь с обновленным расстоянием.
5. По завершении алгоритма для каждой вершины будет найдено кратчайшее расстояние от начальной вершины.

### Почему улучшение работает с разреженными графом

// TODO разобраться с этим подпунктом. Объяснить, почему у нас выходит такое время

В алгоритме Дейкстры, без использования минимальной кучи, на каждой итерации выбирается вершина с наименьшим расстоянием из множества всех вершин. Время выбора такой вершины изначально зависит от количества вершин (V итераций \* V вершин = V\*\*2).

Минимальная куча позволяет хранить вершины и их текущие расстояния таким образом, что выбор вершины с наименьшим расстоянием происходит за время O(logV) (вспомним про просеивание вниз). Это обеспечивает значительное ускорение алгоритма для разреженных графов, где количество ребер (E) намного меньше количества вершин (V).

В плотных графах может возникнуть ситуация, когда количество ребер в графе составляет O(V^2). Тогда куча становится близкой к полной, и операции с ней могут занять дополнительное время, что может быть неэффективно в сравнении с предыдущим алгоритмом.

## Реализация алгоритма на Java

Создадим классы Edge и Node для реализации обоих алгоритмов

```java
    static class Edge {
        public int neighbor; // vertex соседа
        public int weight; // вес ребра


        public Edge(int neighbor, int weight) {
            this.neighbor = neighbor;
            this.weight = weight;
        }
}
```

```java
    static class Node implements Comparator<Node> {
        public int vertex; // значение вершины
        public int distance; // текущее расстояние

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        // Метод статического класса. Сравнивает две вершины по их расстояниям
        public int compare(Node node1, Node node2) {
            if (node1.distance < node2.distance) {
                return -1;
            }
            if (node1.distance > node2.distance) {
                return 1;
            }
            return 0;
        }
    }
```

Хранение взвешенного графа происходит с помощью списка смежности. Граф - словарь, где ключ - int vertex, а значение - массив всех ребер, исходящих из вершины ориентированного графа. Вес ребра между вершинами обозначается целым числом, а отсутствие ребра либо нулем, либо с помощью специального значения

```java
Map<Integer, List<Edge>> graph = new HashMap<Integer, List<Edge>>();
```

Пример графа:

```java
graph = {
    1: [new Edge(2,7), new Edge(3,1)],
    2: [new Edge(1,7), new Edge(4,3)],
    3: [new Edge(4,2), new Edge(6,1), new Edge(1,1)],
    4: [new Edge(2,3), new Edge(5,4), new Edge(3,2)],
    5: [new Edge(4,4), new Edge(7,5), new Edge(8,20)],
    6: [new Edge(3,1), new Edge(7,13), new Edge(9,9)],
    7: [new Edge(6,13), new Edge(9,1), new Edge(8,3), new Edge(5,5)],
    8: [new Edge(5,10), new Edge(7,3), new Edge(9,6)],
    9: [new Edge(6,9), new Edge(7,1), new Edge(8,6)]
}
```

# 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке

## Определение динамического программирования

Динамическое программирование — это метод решения задач, основанный на **разбиении исходной задачи на более мелкие подзадачи**, решение каждой из которых производится только один раз, после чего результаты **сохраняются для дальнейшего использования** при решении большей задачи.

Динамическое программирование часто используется для задач оптимизации, например, нахождения минимального пути или наибольшей подпоследовательности.

## Основные понятия

**Оптимальная подструктура** в динамическом программировании означает, что оптимальное **решение подзадач меньшего размера может быть использовано для решения исходной задачи**. В общем случае мы можем решить задачу, в которой присутствует оптимальная подструктура, проделывая следующие три шага.

1. Разбиение задачи на подзадачи меньшего размера.
2. Нахождение оптимального решения подзадач рекурсивно, проделывая такой же трёхшаговый алгоритм.
3. Использование полученного решения подзадач для конструирования решения исходной задачи.

В этом алгоритме решение задачи строится **путем рекурсивного разбиения ее на подзадачи и нахождения оптимальных решений для них**. Затем эти оптимальные решения сохраняются и используются для вычисления оптимального решения всей задачи.

Принцип оптимальности Беллмана является основной идеей динамического программирования. Он заключается в том, что **оптимальное решение задачи содержит в себе оптимальные решения ее подзадач**.
Более формально, принцип оптимальности Беллмана можно сформулировать следующим образом: Если задача может быть разбита на подзадачи, и оптимальное решение задачи можно выразить через оптимальные решения ее подзадач, то оптимальное решение всей задачи будет содержать в себе оптимальные решения подзадач.

В решении задач методами динамического программирования необходимо сохранять результаты вычислений для повторного использования. Этот процесс называется мемоизация. При использовании мемоизации результаты вычислений подзадач сохраняются в структуре данных (обычно в массиве или хеш-таблице), чтобы избежать повторных вычислений.

Итого, ключевые слова и понятия ДП: рекурсивное определение задач, принцип оптимальности Беллмана, оптимальные подструктуры, мемоизация

## Задача про кузнечика

Задача про кузнечика — это стандартный пример задачи, которая решается с помощью динамического программирования.

### Задача

найти количество способов, которыми кузнечик может добраться из точки 1 до точки N, прыгая только на 1 или 2 шага вперед.

### Решение

Создадим массив dp размером N+1, где dp[i] будет хранить количество способов, которыми кузнечик может добраться из точки 1 до точки i.

### Алгоритм

1. dp[0] равна нулю
2. Начальные значения dp[1] и dp[2] будут равны 1 и 2 соответственно - в первую он может прыгнуть только одним прыжком, во вторую с помощью двух одинарных прыжков и с помощью одного двойного
3. Затем мы будем заполнять массив dp с помощью цикла от 3 до N. Для каждого i мы будем находить сумму dp[i-1] и dp[i-2], так как кузнечик может добраться до точки i из точки i-1 или i-2. Таким образом, dp[i] будет равно количеству способов, которыми кузнечик может добраться до точки i.
4. В конце мы вернем значение dp[N], которое будет равно количеству способов, которыми кузнечик может добраться из точки 1 до точки N.

## Задача о черепашке

### Задача

Черепашка находится в левом верхнем углу сетки размером N x M и должна добраться до правого нижнего угла. Черепашка может двигаться только вниз или вправо. Каждая ячейка сетки имеет определенное значение, которое представляет стоимость прохождения черепашки через эту ячейку. Наша задача состоит в том, чтобы найти путь с минимальной стоимостью от начальной позиции до конечной позиции.

### Решение

Для решения этой задачи с использованием динамического программирования, мы можем создать дополнительную сетку размером N x M, где каждая ячейка будет содержать минимальную стоимость достижения этой ячейки из начальной позиции. Давайте назовем эту сетку dp.

### Алгоритм

1. Инициализируем первую строку и первый столбец сетки dp суммой стоимостей ячеек, по которым проходит черепашка.
2. Для каждой ячейки dp[i][j], где i>0 и j>0, вычисляем минимальную стоимость достижения этой ячейки, используя формулу:

```python
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
# dp[i-1][j] - движение влево
# dp[i][j-1] - движение вверх

# где grid[i][j] - это стоимость текущей ячейки
```

3. После прохода через всю сетку dp, значение dp[N-1][M-1] будет содержать минимальную стоимость достижения конечной позиции.
4. Таким образом, ответ на задачу будет равен dp[N-1][M-1].

# 5. Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы

## Определение задачи о рюкзаке

Задача о рюкзаке - это классическая задача комбинаторной оптимизации. У нас есть рюкзак определенной вместимости (пусть он задан максимальным весом), и у нас есть набор предметов, каждый из которых имеет свой вес и стоимость. Наша задача - выбрать определенный набор предметов, чтобы их суммарная стоимость была максимальной, при условии, что их суммарный вес не превышает вместимость рюкзака.

## Постановка задачи о рюкзаке

Дано: набор предметов с заданными весами, стоимостями и вместимость рюкзака.
Ограничения: каждый предмет может быть выбран только один раз (или 0 раз, то есть не выбран).
Цель: максимизировать суммарную стоимость выбранных предметов.

## Решение методом динамического программирования

Решение классической задачи о рюкзаке с помощью динамического программирования основывается на принципе **оптимальной подструктуры и повторных вычислениях**.

Алгоритм решения

1. Создаем двумерный массив dp размером (n+1) на (W+1), где n - количество предметов, W - вместимость рюкзака.

- Строки от 0 до n+1: Комбинация предметов, которые мы рассматриваем для упаковки в рюкзак. Индекс строки от 1 до n соответствует номеру предмета. Например, dp[1] будет соответствовать первому предмету, dp[2] - второму предмету и так далее.

Столбцы от 0 до W+1: Каждый столбец массива dp соответствует вместимости рюкзака для определенной вместимости. Например, dp[i][1] будет соответствовать вместимости рюкзака равной 1, dp[i][2] - вместимости 2 и так далее.

Таким образом, каждая ячейка dp[i][j] в массиве dp содержит максимальную стоимость, которую можно достичь с использованием предметов с индексами от 1 до i при вместимости рюкзака j.

2. Инициализируем первую строку dp нулями, так как при отсутствии предметов стоимость будет равна нулю.
3. Заполняем массив dp построчно и поэлементно с использованием рекуррентного соотношения.
   Для каждого предмета i (от 1 до n) и вместимости рюкзака j (от 1 до W) выполняем следующие шаги:

   - Если вес предмета i больше текущей вместимости j, то пропускаем его и оставляем значение dp[i][j] равным значению dp[i-1][j].
   - Если вес предмета i меньше или равен текущей вместимости j, то выбираем максимум из двух вариантов:
   - Не включать предмет i: dp[i][j] = dp[i-1][j].
   - Включить предмет i: dp[i][j] = стоимость предмета i + dp[i-1][j-вес предмета i], где второе слагаемое - это стоимость груза до добавление нового веса.
     Значение dp[i][j] будет равно максимальной стоимости из этих двух вариантов.

4. В итоге, максимальная стоимость, которую можно получить, будет находиться в ячейке dp[n][W].
5. Чтобы восстановить выбранный набор предметов, начинаем с ячейки dp[n][W] и движемся назад по массиву dp. Если значение dp[i][j] отличается от dp[i-1][j], значит предмет i был включен в рюкзак. Переходим к ячейке dp[i-1][j-вес предмета i] и продолжаем обратное движение до ячейки dp[1][1], восстанавливая выбранные предметы.

## Оценка времени работы

Временная сложность решения классической задачи о рюкзаке с помощью динамического программирования зависит от количества предметов n и вместимости рюкзака W.

Время выполнения программы составляет O(n \* W). Это связано с двойным циклом, с помощью которого мы проходимся по созданной матрице dp. Во время цикла мы рассматриваем каждый предмет и каждую возможную вместимость рюкзака.

# 6. Задача поиска наибольшей возрастающей подпоследовательности в массиве. Решение за O(N^2) методом динамического программирования. Решение за O(NlogN) методом динамического программирования

## Формулировка задачи

Задача поиска наибольшей возрастающей подпоследовательности в числовом массиве заключается в нахождении подпоследовательности элементов, которая строго возрастает и имеет максимальную длину.

Дано: массив arr
Задача: найти длину наибольшей возрастающей подпоследовательности

## Алгоритм решения задачи за O(N^2)

1. Создаем массив dp длины N, где N - количество элементов в исходном массиве. Инициализируем все элементы dp значением 1, так как каждый элемент сам по себе является возрастающей подпоследовательностью длины 1.
2. Проходимся по массиву элементов и для каждого элемента arr[i], начиная с индекса 1, сравниваем его со всеми предыдущими элементами arr[j], где j меньше i.
3. Если arr[i] больше arr[j], то значит мы можем продолжить предыдущую возрастающую подпоследовательность, добавив arr[i] к ней.
   Мы обновляем значение dp[i] путем выбора максимальной длины из dp[j] + 1 (длина предыдущей подпоследовательности, к которой мы добавляем текущий элемент) и текущего значения dp[i].

```python
dp[i] = max(dp[i], dp[j] + 1)
```

Это означает, что мы увеличиваем значение dp[i] только в случае, если добавление arr[i] к возрастающей подпоследовательности, заканчивающейся на arr[j], даст нам более длинную подпоследовательность.

4. Повторяем шаги 2-3 для всех элементов массива arr.
5. Находим максимальное значение в массиве dp, которое будет представлять длину наибольшей возрастающей подпоследовательности.

### Пример

0. arr = [3, 1, 5, 2, 4, 6]. dp = [1, 1, 1, 1, 1, 1]
1. arr[0] = 3. Не имеем предыдущих элементов, поэтому dp[1] остается 1
2. Для элемента arr[1] = 1.
   - arr[1]>arr[0] (1>3) - условие не выполняется, поэтому dp[1] остается 1

dp = [1, 1, 1, 1, 1, 1]

3. arr[2] = 5, сравниваем с предыдущими элементами:

- arr[2] > arr[0] (5 > 3), поэтому обновляем dp[2] = max(dp[2], dp[1]+1) = max(1, 1+1) = 2
- arr[2] > arr[1] (5 > 1), поэтому обновляем dp[2] = max(dp[2], dp[1] + 1) = max(2, 1 + 1) = 2.

dp = [1, 1, 2, 1, 1, 1]

4. arr[3] = 2, сравниваем с предыдущими элементами:
   - arr[3] > arr[0] (2 > 3) не выполняется, поэтому оставляем dp[3] = 1
   - arr[3] > arr[1] (2 > 1), поэтому обновляем dp[3] = max(dp[3], dp[1] + 1) = max(1, 1 + 1) = 2.
   - arr[3] > arr[2] (2 > 5), условие не выполняется, оставляем dp[3] = 2.

dp = [1, 1, 2, 2, 1, 1]

5. arr[4] = 4, сравниваем с предыдущими элементами:

   - arr[4] > arr[0] (4 > 3), поэтому обновляем dp[4] = max(dp[4], dp[0]+1) = max(1, 1+1) = 2
   - arr[4] > arr[1] (4 > 1), поэтому обновляем dp[4] = max(dp[4], dp[1] + 1) = max(2, 1 + 1) = 2.
   - arr[4] > arr[2] (4 > 5), условие не выполняется, оставляем dp[4] = 2.
   - arr[4] > arr[3] (4 > 2), поэтому обновляем dp[4] = max(dp[4], dp[3] + 1) = max(2, 2 + 1) = 3.

dp = [1, 1, 2, 2, 3, 1]

6. Для элемента arr[5] = 6, сравниваем с предыдущими элементами:
   - arr[5] > arr[0] (6 > 3), поэтому обновляем dp[5] = max(dp[5], dp[0] + 1) = max(1, 1 + 1) = 2.
   - arr[5] > arr[1] (6 > 1), поэтому обновляем dp[5] = max(dp[5], dp[1] + 1) = max(2, 1 + 1) = 2.
   - arr[5] > arr[2] (6 > 5), поэтому обновляем dp[5] = max(dp[5], dp[2] + 1) = max(2, 2 + 1) = 3.
   - arr[5] > arr[3] (6 > 2), поэтому обновляем dp[5] = max(dp[5], dp[3] + 1) = max(3, 2 + 1) = 3.
   - arr[5] > arr[4] (6 > 4), поэтому обновляем dp[5] = max(dp[5], dp[4] + 1) = max(3, 3 + 1) = 4.

dp = [1, 1, 2, 2, 3, 4]

## Алгоритм решения задачи за O(NlogN)

1. Создаем пустой массив tails, который будет хранить нарастающие подпоследовательности. Устанавливаем его первый элемент равным первому элементу исходного массива.
2. Проходим по остальным элементам исходного массива, начиная со второго элемента.
3. Для каждого элемента arr[i] выполняем бинарный поиск в массиве tails , чтобы найти самую правую позицию, на которую можно вставить arr[i] так, чтобы поддерживать возрастающую последовательность.
   - Если найденная позиция равна длине массива tails, то добавляем arr[i] в конец tails, так как он может продлить наибольшую возрастающую подпоследовательность.
   - В противном случае заменяем элемент в найденной позиции на arr[i], так как это обновление приводит к созданию новой возрастающей подпоследовательности, более длинной или равной предыдущей.
4. В конце процесса длина массива tails будет представлять длину наибольшей возрастающей подпоследовательности.

### Пример

0. arr = [3, 1, 5, 2, 4, 6]
1. Инициализируем массив tails с первым элементом arr[0]: tails = [3]
2. Рассматриваем arr[1] = 1:

   - Выполняем бинарный поиск в массиве tails. Так как 1 меньше элемента 3, найденная позиция равна 0.
   - Заменяем элемент в найденной позиции на 1.

tails = [1].

3.  Рассматриваем arr[2] = 5:
    - Выполняем бинарный поиск в массиве tails. Так как 5 больше всех элементов в tails, найденная позиция равна длине массива tails (1).
    - Добавляем 5 в конец массива tails.

tails = [1, 5].

4. Рассматриваем arr[3] = 2:
   - Выполняем бинарный поиск в массиве tails. Так как 2 меньше элемента 5, найденная позиция равна 1.
   - Заменяем элемент в найденной позиции на 2.

tails = [1, 2].

5. Рассматриваем arr[4] = 4:
   - Выполняем бинарный поиск в массиве tails. Так как 4 больше всех элементов в tails, найденная позиция равна длине массива tails (2).
   - Добавляем 4 в конец массива tails.

tails = [1, 2, 4].

6. Рассматриваем arr[5] = 6:

- Выполняем бинарный поиск в массиве tails. Так как 6 больше всех элементов в tails, найденная позиция равна длине массива tails (3).
- Добавляем 6 в конец массива tails

tails = [1, 2, 4, 6].

7. Длина наибольшей возрастающей подпоследовательности равна длине массива tails, то есть 4.

// TODO добавить код обоим алгоритмам

# Задача поиска длины наибольшей общей подпоследовательности двух строк. Решение за O(n\*m) методом динамического программирования

## Постановка задачи

Дано: две строки s1 длиной n и s2 длиной m
Цель: найти длину наибольшей общей подпоследовательности двух строк

## Алгоритм решения

1. Создаем двумерный массив dp размером (n+1) x (m+1). Здесь dp[i][j] будет представлять длину наибольшей общей подпоследовательности для подстрок s1[0:i] и s2[0:j].
2. Инициализируем первую строку и первый столбец массива dp нулями, так как при пустых подстроках длина наибольшей общей подпоследовательности равна нулю.
3. Для каждого i от 1 до n и для каждого j от 1 до m:
   - Если s1[i-1] равно s2[j-1], то dp[i][j] равно dp[i-1][j-1] + 1. То есть, добавляем символы s1[i-1] и s2[j-1] к текущей общей подпоследовательности.
   - В противном случае, dp[i][j] равно максимуму между dp[i-1][j] и dp[i][j-1].
     То есть, выбираем наибольшую длину из подпоследовательности без символа s1[i-1] и подпоследовательности без символа s2[j-1].
4. По окончании заполнения массива dp, значение dp[n][m] будет содержать длину наибольшей общей подпоследовательности двух строк s1 и s2.

Алгоритм использует подзадачи, где мы сравниваем символы с конца строк. Заполняя массив dp построчно, мы постепенно увеличиваем длину подпоследовательности, сравнивая символы исходных строк и сохраняя промежуточные результаты.

## Пример

0.  Даны две строки "ABCDGH" и "AEDFHR", n = 6, m = 6
1.  Создаем двумерным массив размером 7x7
2.  Инициализируем первую строку и первый столбец массива dp нулями:

    |     |     | A   | E   | D   | F   | H   | R   |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |     | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
    | A   | 0   |     |     |     |     |     |     |
    | B   | 0   |     |     |     |     |     |     |
    | C   | 0   |     |     |     |     |     |     |
    | D   | 0   |     |     |     |     |     |     |
    | G   | 0   |     |     |     |     |     |     |
    | H   | 0   |     |     |     |     |     |     |

3.  s1[0]=s2[0], поэтому dp[1][1] = dp[0][0]+1 = 1
4.  s1[0]!=s2[1], поэтому dp[1][2] = max(dp[0][2], dp[1][1]) = max(0,1) = 1

    |     |     | A   | E   | D   | F   | H   | R   |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |     | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
    | A   | 0   | 1   | 1   |     |     |     |     |
    | B   | 0   |     |     |     |     |     |     |
    | C   | 0   |     |     |     |     |     |     |
    | D   | 0   |     |     |     |     |     |     |
    | G   | 0   |     |     |     |     |     |     |
    | H   | 0   |     |     |     |     |     |     |

5.  Продолжаем заполнять остальные ячейки аналогичным способом

    |     |     | A   | E   | D   | F   | H   | R   |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    |     | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
    | A   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
    | B   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
    | C   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
    | D   | 0   | 1   | 1   | 2   | 2   | 2   | 2   |
    | G   | 0   | 2   | 2   | 2   | 2   | 2   | 2   |
    | H   | 0   | 2   | 2   | 2   | 2   | 3   | 3   |

6.  Значение dp[6][6] равно 3, что означает, что длина наибольшей общей подпоследовательности двух строк "ABCDGH" и "AEDFHR" равна 3.

Действительно, наибольшая общая подпоследовательность этих двух строк состоит из символов 'A', 'D' и 'H'.

## Оценка времени выполнения

Так как мы проходимся по матрице n\*m с помощью двойного цикла, время выполнения программы будет составлять O(n\*m).

// TODO добавить код

# Дерево отрезков

// TODO переделать алгоритм построения, пример построения. Написать операции

## Определение

Дерево отрезков (Segment Tree) - это структура данных, которая представляет собой бинарное дерево, где каждый узел соответствует некоторому отрезку массива.

В дереве отрезков каждый узел хранит информацию о сумме, минимуме, максимуме или другой функции значений на соответствующем отрезке массива. Корень дерева представляет весь массив, а каждый узел дробит его на две половины. Левый и правый потомки узла представляют левую и правую половины отрезка. Листья дерева - отдельные элементы массива

## Примере дерева отрезка

```
     36 [0-5]
   /    \
  9      27
 / \    /  \
 4  *5  16  *11
/  \    / \
*1  *3  *7 *9
```

В данном дереве листья 1,3,5,7,9 и 11 - элементы массива. Каждая остальная вершина - операция сложения потомков. Например, 4 = 1+3 или 27 = (7+9) + 11

## Варианты деревьев отрезков

Ниже представлены некоторые примеры возможных типов деревьев

1. Суммовое дерево отрезков (Segment Tree): В этом типе дерева отрезков каждый узел хранит сумму значений в соответствующем отрезке массива.
2. Минимальное/Максимальное дерево отрезков: В этом типе дерева отрезков каждый узел хранит минимальное или максимальное значение в соответствующем отрезке массива.
3. Дерево отрезков для операции XOR: В этом типе дерева отрезков каждый узел хранит результат операции XOR для соответствующего отрезка массива.
4. Дерево отрезков для операции НОД (наибольший общий делитель): В этом типе дерева отрезков каждый узел хранит наибольший общий делитель для соответствующего отрезка массива.

## Расположение элементов в дереве отрезков

Значение вершин хранятся в массиве tree, где tree[v] - значение в вершине v  
Дети вершины: 2\*v+2 и 2\*v+1

## Построение дерева отрезков из массива

1. Начнем с изначального массива значений, который будет служить основой для построения дерева отрезков.
2. Воспользуемся структурой данных бинарное дерево, где каждый узел представляет отрезок массива. Корень дерева будет соответствовать всему массиву, а каждый лист дерева будет представлять один элемент массива.
3. Создадим пустой массив, размер которого будет равен 4n.
4. Рекурсивно разделим массив пополам, создавая левое и правое поддерево. Каждый узел дерева будет содержать сумму значений своих потомков.
5. Продолжим делить массив пополам и строить поддеревья до тех пор, пока не достигнем листьев дерева (отдельные элементы массива).
6. В каждом узле дерева будем хранить агрегированную информацию, например, сумму значений отрезка, минимальное или максимальное значение и т. д. Это позволит нам эффективно выполнять запросы на отрезках.
7. После построения дерева отрезков мы можем использовать его для выполнения различных операций, таких как запросы суммы, поиска минимума или максимума на отрезке, обновления значений элементов и других.

### Пример построения дерева отрезков

1. Создаем новый массив tree с размером, достаточным для хранения узлов дерева отрезков. Для данного массива размер будет равен ближайшей степени двойки, большей или равной удвоенной длине исходного массива. В данном случае, длина исходного массива равна 6, удвоенная длина это 12, поэтому размер tree будет 16 (ближайшая степень двойки большая или равная 12\*2 <= 2\*\*4 = 16).
2. Начинаем заполнять узлы массива tree значениями из исходного массива. Узлы, соответствующие листьям дерева, будут содержать элементы исходного массива.
   [0,0,0,0,0,...,].
3. После заполнения листьев, мы начинаем заполнять остальные узлы дерева отрезков, перемещаясь от листьев к корню. Каждый узел будет содержать сумму значений своих дочерних узлов. Для каждого узла с индексом i (где i > n, где n - количество элементов в исходном массиве), сумма его дочерних узлов будет равна tree[2i] + tree[2i+1].

Повторяем шаг 3 до достижения корня дерева (узел с индексом 1). Корневой узел будет содержать сумму всех элементов исходного массива.

### Время выполнения алгоритма

# 8. Поиск суммы на отрезке + изменение значения в массиве. Постановка задачи, решение за O(logN) при помощи дерева отрезков. Построение дерева отрезков.

## 9. Поиск минимума на отрезке + изменение значения в массиве. Постановка задачи, решение за O(log N) при помощи дерева отрезков. Построение дерева отрезков.

## 10. Алгоритм Форда-Беллмана. Описание алгоритма. Оценка времени выполнения

## Определение алгоритма Форда-Беллмана

Алгоритм Беллмана-Форда - это алгоритм поиска кратчайшего пути во взвешенном ориентированном графе с возможными отрицательными весами ребер.

## Условие работы алгоритма Форда-Беллмана

- Отсутствие отрицательных циклов в графе

Отрицательный цикл в графе - это цикл, сумма весов ребер которого отрицательна.
Он может привести к бесконечному уменьшению стоимости пути. Если в графе присутствует отрицательный цикл, то мы можно обойти его бесконечное количество раз и уменьшить стоимость пути. Это не соответствует нашей задаче

## Описание алгоритма

1. Инициализация

   - Задаем начальную вершину start исходного графа.
   - Устанавливаем расстояние до всех вершин, кроме start, равным бесконечности, а расстояние до start равным 0.

2. Релаксация ребер

   - Проходим по всем ребрам графа E.
   - Для каждого ребра (u, v) проверяем, можно ли улучшить расстояние до вершины v через вершину u. Если да, то обновляем расстояние до v на значение

   ```python
   dist[v] = dist[u] + weight(u, v)
   # где dist[u] — текущее расстояние до вершины u, а weight(u, v) — вес ребра (u, v).
   ```

3. Проверка наличия отрицательных циклов

- Проходим по всем ребрам графа E еще раз.
- Если мы можем улучшить расстояние до вершины v через вершину u, то это означает наличие отрицательного цикла в графе. В этом случае алгоритм не может найти оптимальные расстояния, и мы завершаем его с сообщением о наличии отрицательного цикла.

4. Вывод результатов

Алгоритм Беллмана-Форда работает за время O(V\*E), где V — количество вершин, а E — количество ребер в графе. Он может быть использован для решения задачи поиска кратчайшего пути в графе, даже если в нем присутствуют ребра с отрицательными весами или циклы отрицательного веса.

## Временная сложность

Временная сложность алгоритма Беллмана-Форда - O(VE), где V - число вершин графа, E - число ребер графа.

## Дополнительная память

Затраты памяти алгоритма Беллмана-Форда составляют O(V), где V - количество вершин в графе. Это связано с тем, что для каждой вершины мы храним ее минимальное расстояние от начальной вершины dist[v].
