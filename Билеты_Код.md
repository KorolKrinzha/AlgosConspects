## 5. Бинарный поиск. Задача поиска элемента в отсортированном массиве - постановка задачи, оценка сложности алгоритма.

### Задача поиска элемента в отсортированном массиве

```java
public static int binarySearch(int[] a, int x) {
    int left = 0;
    int right = a.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (a[mid] == x) {
            // элемент найден
            return mid;
        } else if (a[mid] < x) {
            // элемент может находиться в правой половине массива
            left = mid + 1; // сдвигаем левую границу вправо
        } else {
            // элемент может находиться в левой половине массива
            right = mid - 1; // сдвигаем правую границу в лево
        }
    }

    // элемент не найден
    return -1;
}
```

## 7. Двоичная куча

### Построение кучи из массива

```java
public static void buildHeap(int[] arr) {
    int n = arr.length;
    // Начинаем с середины массива
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
}

private static void heapify(int[] arr, int n, int i) {
    while (true) {
        int maxIndex = i;
        int leftChild = 2 * i + 1;
        int rightChild = 2 * i + 2;

        // Сравниваем текущий элемент с левым дочерним
        if (leftChild < n && arr[leftChild] > arr[maxIndex]) {
            maxIndex = leftChild;
        }

        // Сравниваем текущий элемент с правым дочерним
        if (rightChild < n && arr[rightChild] > arr[maxIndex]) {
            maxIndex = rightChild;
        }

        // Если текущий элемент является наибольшим, то свойство кучи сохранено
        if (maxIndex == i) {
            break;
        }

        // Меняем местами текущий элемент с наибольшим дочерним элементом
        int temp = arr[i];
        arr[i] = arr[maxIndex];
        arr[maxIndex] = temp;

        // Переходим на уровень выше и продолжаем сравнение
        i = maxIndex;
    }
}
```

### Операции sift Down и sift Up

```java


```

## 8. Квадратичные сортировки (пузырьком, вставками, выбором), сортировка с помощью двоичной кучи. Описание алгоритмов, оценка времени работы и дополнительной памяти.

### Сортировка пузырьком

```java
public class BubbleSort {
   public static void bubbleSort(int[] arr) {
      int n = arr.length;
      int temp = 0;
      for(int i = 0; i < n; i++) {
         for(int j=1; j < (n-i); j++) {
            if(arr[j-1] > arr[j]) {
                // если arr[j-1] больше, то он "всплывает"
               temp = arr[j-1];
               arr[j-1] = arr[j];
               arr[j] = temp;
            }
         }
      }
   }
```

### Сортировка выбором

```java
public static void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        // начинаем с первого элемента неотсортированой части
        int minIndex = i;

        // в этом цикле смотрим все оставшиеся элементы
        for (int j = i + 1; j < n; j++) {
            // находим наименьший элемент
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        // меняем местами минимальный элемент и 1ый элемент из неотсортированной части
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
        // теперь это часть сортированной части
    }
}
```

### Сортировка вставками

```java
public static void insertionSort(int[] arr) {
    int n = arr.length;
    // проходим по всему массиву, начиная со второго элемента
    for (int i = 1; i < n; i++) {
        int key = arr[i]; // key - элемент, который мы будем вставлять
        int j = i - 1; // указатель на последний элемент сортированной части
        // сдвигаем все элементы, которые больше, чем key, на одну позицию вправо
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // продвигаем элементы вперед, чтобы дать место новому
            j--;
        }
        arr[j + 1] = key; // вставляем key в отсортированную часть массива
    }
}
```

### Сортировка кучей

## 9. Сортировка слиянием. Описание алгоритма, оценка времени работы

### Слияние двух отсортированных массивов

```java
// Метод для слияния двух отсортированных половин массива
public static void merge(int[] arr, int left, int mid, int right) {
    int[] temp = new int[right - left + 1];
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k] = arr[i];
            i++;
        } else {
            temp[k] = arr[j];
            j++;
        }
        k++;
    }
    // Добавляем оставшиеся элементы из левой половины
    while (i <= mid) {
        temp[k] = arr[i];
        i++;
        k++;
    }
    // Добавляем оставшиеся элементы из правой половины
    while (j <= right) {
        temp[k] = arr[j];
        j++;
        k++;
    }
    // Копируем временный массив обратно в основной
    for (int p = 0; p < temp.length; p++) {
        arr[left + p] = temp[p];
    }
}
```

### Сортировка слиянием

```java

public static void main(String[] args) {
        int[] arr = { 10, 2, 5, 7, 1, 6, 8, 4, 3, 9 };
        System.out.println("Original Array: " + Arrays.toString(arr));
        mergeSort(arr, 0, arr.length - 1);
        System.out.println("Sorted Array: " + Arrays.toString(arr));
}

// Метод для сортировки массива
public static void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        // Сортируем левую половину
        mergeSort(arr, left, mid);
        // Сортируем правую половину
        mergeSort(arr, mid + 1, right);

        // Слияние двух половин
        merge(arr, left, mid, right);
    }
}
```

## 10. Быстрая сортировка. Описание алгоритма, оценка времени работы в лучшем, среднем и худшем случае.

```java
import java.util.Random;

public class QuickSort {
    public static void main(String[] args) {
        int[] arr = { 9, 4, 7, 6, 5, 2, 1, 3, 8 };
        quickSort(arr, 0, arr.length - 1);
    }

    //  рекурсивно вызывает метод partition, который разделяет массив на две части и возвращает индекс опорного элемента, после чего вызывает себя для левой и правой частей массива.
    public static void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(arr, left, right);
            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);
        }
    }


    public static int partition(int[] arr, int left, int right) {
        // Выбираем индекс как опорный
        int pivotIndex = new Random().nextInt(right - left + 1) + left;
        int pivotValue = arr[pivotIndex]; // сохраняем значение опорного

        // Перемещаем опорный элемент в конец массива
        swap(arr, pivotIndex, right);
        int storeIndex = left; // запоминаем куда поставит опорный элемент
        // Проходим по массиву и перемещаем элементы меньше опорного элемента
        // в начало массива
        for (int i = left; i < right; i++) {
            if (arr[i] < pivotValue) {
                swap(arr, i, storeIndex);
                storeIndex++;
            }
        }
        // Перемещаем опорный элемент на своё место
        swap(arr, storeIndex, right);
        return storeIndex;

        // оставшиеся элементы будут элементами, большими опорного
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

