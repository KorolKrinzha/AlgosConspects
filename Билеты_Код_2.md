# 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2+E). Улучшение алгоритма для разреженных графов за O(E\*logV)

## Алгоритм для разреженных графов за O(E\*logV)

```java
import java.util.*;

public class DijkstraAlgorithm {
    public static void main(String[] args) {
        Map<Integer, List<Edge>> graph = new HashMap<Integer, List<Edge>>();

        // добавление вершин и ребер в граф
        // ...

        int startVertex = 1; // начальная вершина для поиска кратчайшего пути
        int[] distances = dijkstra(graph, startVertex);
        System.out.println(Arrays.toString(distances)); // печать массива кратчайших расстояний от startVertex до остальных вершин
    }

    public static int[] dijkstra(Map<Integer, List<Edge>> graph, int startVertex) {
        int n = graph.size();
        int[] distances = new int[n+1];
        Arrays.fill(distances, Integer.MAX_VALUE); // по аналогии с бесконечность, бесконечность, бесконечность...
        distances[startVertex] = 0; // мы уже там, где начальная вершина. Расстояние равно 0
        PriorityQueue<Node> pq = new PriorityQueue<Node>(n, new Node()); // создание хранилища для вершин графа, которые еще не были посещены.

        // добавляем начальную вершину в очередь - начинаем с нее
        pq.add(new Node(startVertex, 0));

        // обходим граф
        while (!pq.isEmpty()) {
            // берем наименьшую вершину
            Node currentNode = pq.poll();
            int currentVertex = currentNode.vertex;
            int currentDistance = currentNode.distance;

            // проверяем все смежные вершины - достаем list по id currentVertex
            List<Edge> edges = graph.get(currentVertex);
            if (edges != null) {
                for (Edge edge : edges) {
                    int neighbor = edge.neighbor;
                    int weight = edge.weight;
                    int distance = currentDistance + weight;

                    if (distance < distances[neighbor]) {
                        // если найден более короткий путь, обновляем кратчайшее расстояние и добавляем вершину в очередь
                        distances[neighbor] = distance;
                        pq.add(new Node(neighbor, distance));
                    }
                }
            }
        }

        return distances;
    }

    // имплементируем компаратор, чтобы можно было сравнивать node
    // и распределять их по приоритету
    static class Node implements Comparator<Node> {
        public int vertex; // значение вершины
        public int distance; // текущее расстояние

        public Node() {}

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        // Метод статического класса. Сравнивает две вершины по их расстояниям
        public int compare(Node node1, Node node2) {
            if (node1.distance < node2.distance) {
                return -1;
            }
            if (node1.distance > node2.distance) {
                return 1;
            }
            return 0;
        }
    }


    // реализация ребра, которую мы обсудили ранее
    static class Edge {
        public int neighbor;
        public int weight;

        public Edge() {}

        public Edge(int neighbor, int weight) {
            this.neighbor = neighbor;
            this.weight = weight;
        }
    }
}
```
