# 1. Хеширование. Полиномиальная функция. Алгоритм Рабина-Карпа. Оценка времени выполнения функции

## Использование полиномиальной функции для хеширования. Алгоритм Рабина-Карпа

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    private static final int PRIME = 101; // задаем простое число для хэша

    public static List<Integer> search(String text, String pattern) {
        // в списке храним все значения
        List<Integer> occurrences = new ArrayList<>();

        int patternHash = calculateHash(pattern); // создаем хэш для паттерна
        int textHash = calculateHash(text.substring(0, pattern.length()));
        // первое "окно" для проверки начинается с нулевого индекса

        // цикл продолжается до тех пор, пока не будут проверены все окна
        // при каждом сдвиге окно переносится на 1
        for (int i = 0; i <= text.length() - pattern.length(); i++) {
            // если текущий хэш совпадает с искомым
            if (textHash == patternHash) {
                // если верно, то проверяем на коллизию
                if (text.substring(i, i + pattern.length()).equals(pattern)) {
                    occurrences.add(i);
                }
            }

            // Если i меньше чем разница длины text и pattern,
            // мы пересчитываем хэш для следующей итерации цикла.
            // Мы делаем это, удаляя первый предыдущий символ и добавляя следующий.
            // переходим к следующему окну размером pattern.length() в тексте
            if (i < text.length() - pattern.length()) {
                textHash = calculateHash(text.substring(i + 1, i + pattern.length() + 1));
            }
        }

        return occurrences;
    }

    // вычисляем хэш для строки в виде итт-значения
    private static int calculateHash(String str) {
        int hash = 0;
        for (int i = 0; i < str.length(); i++) {
            // hash = (s[0] * p^(n-1)) + (s[1] * p^(n-2)) + ... + (s[n-1] * p^0),
            // s = str.charAt(i) - числовое значение символа
            // p = PRIME - выбранное простое число
            // n = str.length() - длина последовательности символа
            hash += str.charAt(i) * Math.pow(PRIME, str.length() - i - 1);

        }
        return hash;
    }

    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABDABACDABABCABAB";
        List<Integer> occurrences = search(text, pattern);
        if (occurrences.isEmpty()) {
            System.out.println("Pattern not found in the text");
        } else {
            System.out.println("Pattern found at positions: " + occurrences);
        }
    }
}

```

# 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2+E). Улучшение алгоритма для разреженных графов за O(E\*logV)

// TODO добавить обычный алгоритм

## Алгоритм за O(V^2+E)

В этой реализации граф представлен в виде матрицы смежности adjacencyMatrix, где adjacencyMatrix[i][j] представляет собой вес ребра между вершинами i и j. Значение 0 указывает на отсутствие ребра между вершинами.

```java
import java.util.Arrays;

class DijkstraAlgorithm {
    private int V; // число вершин
    private int[][] graph; // граф в виде матрицы смежности

    public DijkstraAlgorithm(int[][] adjacencyMatrix) {
        this.V = adjacencyMatrix.length;
        this.graph = adjacencyMatrix;
    }

    public int[] shortestPath(int source) {

        int[] distance = new int[V]; // создаем массив с расстояниями
        boolean[] visited = new boolean[V]; // создаем пустое множество посещенных вершин

        Arrays.fill(distance, Integer.MAX_VALUE); // всем назначаем "бесконечность"
        distance[source] = 0; // начальная вершина, значение равно нулю

        for (int i = 0; i < V - 1; i++) {
            int minVertex = findMinDistanceVertex(distance, visited);
            visited[minVertex] = true; // помеченную вершину посещаем

            // обновляем расстояния для всех смежных вершин
            // Если новое расстояние до соседней вершины меньше текущего расстояния,
            // то обновляем его
            for (int j = 0; j < V; j++) {
                if (!visited[j]
                        && graph[minVertex][j] != 0
                        && distance[minVertex] != Integer.MAX_VALUE
                        && distance[minVertex] + graph[minVertex][j] < distance[j]) {
                    // вершина j еще не была посещена, между вершинами
                    // minVertex и j существует ребро,
                    // расстояние до minVertex не является бесконечностью
                    // новое расстояние через minVertex до j меньше текущего
                    distance[j] = distance[minVertex] + graph[minVertex][j];
                    // обновляем расстояние
                }
            }
        }

        return distance;
    }

    private int findMinDistanceVertex(int[] distance, boolean[] visited) {
        int minDistance = Integer.MAX_VALUE;
        int minVertex = -1;

        for (int i = 0; i < V; i++) {
            // если ранее не посещена и расстояние меньше
            if (!visited[i] && distance[i] < minDistance) {
                minDistance = distance[i]; // присваиваем минимальное расстояние
                minVertex = i; // возвращаем id вершины, на которую скоро перейдем
            }
        }

        return minVertex;
    }
}

public class Main {
    public static void main(String[] args) {
        int[][] adjacencyMatrix = {
                { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
                { 4, 0, 8, 0, 0, 0, 0, 11, 0 },
                { 0, 8, 0, 7, 0, 4, 0, 0, 2 },
                { 0, 0, 7, 0, 9, 14, 0, 0, 0 },
                { 0, 0, 0, 9, 0, 10, 0, 0, 0 },
                { 0, 0, 4, 14, 10, 0, 2, 0, 0 },
                { 0, 0, 0, 0, 0, 2, 0, 1, 6 },
                { 8, 11, 0, 0, 0, 0, 1, 0, 7 },
                { 0, 0, 2, 0, 0, 0, 6, 7, 0 }
        };

        int source = 0;

        DijkstraAlgorithm dijkstra = new DijkstraAlgorithm(adjacencyMatrix);
        int[] shortestDistances = dijkstra.shortestPath(source);

        System.out.println("Shortest distances from source vertex " + source + ":");
        for (int i = 0; i < shortestDistances.length; i++) {
            System.out.println("Vertex " + i + ": " + shortestDistances[i]);
        }
    }
}
```

## Алгоритм для разреженных графов за O(E\*logV)

```java
import java.util.*;

public class Main {

    public static int[] dijkstra(int[][] graph, int startVertex) {
        int n = graph.length;
        boolean[] visited = new boolean[n];

        // создаем множество с расстояниями, все расстояния временно помечаем как
        // бесконечность
        int[] distances = new int[n];
        Arrays.fill(distances, Integer.MAX_VALUE);
        // расстояние стартовой вершины равно 0
        distances[startVertex] = 0;
        visited[startVertex] = true;
        // создаем пустую минимальную кучу, которая принимает непосещенные вершины
        PriorityQueue<Node> pq = new PriorityQueue<>(n, new Node());
        pq.add(new Node(startVertex, 0)); // добавляем начальную вершину
        // перебираем кучу
        while (!pq.isEmpty()) {
            // Извлекаем вершину с наименьшим текущим расстоянием из приоритетной очереди
            // используя siftDown
            Node currentNode = pq.poll();
            int currentVertex = currentNode.vertex;
            int currentDistance = currentNode.distance;
            visited[currentVertex] = true; // посещаем вершину

            // рассматриваем всех соседей посещенной вершины
            for (int neighbor = 0; neighbor < n; neighbor++) {
                // weight[i][j] - расстояние между i и j
                int weight = graph[currentVertex][neighbor];
                if (weight > 0 && !visited[neighbor]) {
                    int distance = currentDistance + weight; // вычисляем расстояние
                    // если расстояние меньше, чем текущее расстояние
                    if (distance < distances[neighbor]) {
                        distances[neighbor] = distance; // обновляем расстояние
                        pq.add(new Node(neighbor, distance)); // добавляем вершину в кучу
                    }
                }
            }
        }

        return distances;
    }

    public static void main(String[] args) {
        int[][] graph = {
                { 0, 10, 5, 0, 0 },
                { 0, 0, 0, 3, 0 },
                { 0, 2, 0, 9, 0 },
                { 0, 0, 0, 0, 2 },
                { 0, 0, 1, 0, 0 }
        };

        int startVertex = 0;
        int[] distances = dijkstra(graph, startVertex);
        System.out.println(Arrays.toString(distances));
    }

    // используем компаратор для того,
    // чтобы на верху кучи были вершины с наименьшим расстоянием
    static class Node implements Comparator<Node> {
        public int vertex;
        public int distance;

        public Node() {
        }

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        public int compare(Node node1, Node node2) {
            if (node1.distance < node2.distance) {
                return -1;
            }
            if (node1.distance > node2.distance) {
                return 1;
            }
            return 0;
        }
    }
}
```

# 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке.

## Задача о кузнечике

```java
public int countWays(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0; // на нулевую клетку он не может попасть
    dp[1] = 1; // до первой клетки есть единственный способ допрыгнуть - совершить прыжок длиной 1
    dp[2] = 2; // до второй клетки можно прыгнуть за один прыжок длиной 2, либо за два прыжка длиной 1
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]; //кузнечик может прыгнуть на текущую позицию либо из позиции i - 1, либо из позиции i -  2
        // чтобы достичь позиции i, кузнечику необходимо достичь позиции i - 1
        //  затем есть два варианта
        // 1. сделать последний прыжок на одну ступеньку, ИЛИ
        // 2. достичь позиции i - 2 и сделать последний прыжок на две ступеньки. Таким образом, решение задачи сводится к нахождению оптимальных решений подзадач для позиций i - 1 и i - 2.
    }
    return dp[n];
}
```

## Задача о черепашке

```java
public class TurtlePath {
    public static int minPathCost(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;

        int[][] dp = new int[rows][cols];
        dp[0][0] = grid[0][0];

        // Инициализация первой строки
        // В первой строке мы можем двигаться только вправо
        // Поэтому прибавляем предыдущие значения слева
        for (int j = 1; j < cols; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }

        // Инициализация первого столбца
        // В первом столбце двигаемся вниз, прибавляем "верхние значения"
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }

        // Вычисление минимальной стоимости достижения каждой ячейки
        // Начинаем i и j с единицы, так как первые строку и столбец уже проработали
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                // min - для выбора оптимального пути
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }

        return dp[rows-1][cols-1];
    }

    public static void main(String[] args) {
        int[][] grid = {
            {1, 3, 1},
            {1, 5, 1},
            {4, 2, 1}
        };

        int minCost = minPathCost(grid);
        System.out.println("Минимальная стоимость достижения конечной позиции: " + minCost);
    }
}
```

# 5. Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы

```java
public class Main {
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];

        // начинаем с 1, это минимальный id предмета и вместимость рюкзака
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= capacity; j++) {
                // получаем доступ к весу текущего через weights[i - 1]
                if (weights[i - 1] <= j) {
                    // выбираем максимальную стоимость
                    // 1. Включаем предмет через формулу, сложив нынешнюю и старую цену
                    // 2. Не включаем предмет
                    dp[i][j] = Math.max(
                            values[i - 1] + dp[i - 1][j - weights[i - 1]],
                            dp[i - 1][j]);
                    // если вес предмета меньше текущей вместимости
                } else {
                    // пропускаем предмет
                    // оставляем значение dp[i][j] равным значению dp[i-1][j]
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[n][capacity];
    }

    public static void main(String[] args) {
        int[] weights = { 2, 3, 5, 7 };
        int[] values = { 10, 15, 25, 30 };
        int capacity = 10;

        int maxProfit = knapsack(weights, values, capacity);
        System.out.println("Max Profit: " + maxProfit);
    }
}
```

# 6. Задача поиска наибольшей возрастающей подпоследовательности в массиве. Решение за O(N^2) методом динамического программирования. Решение за O(NlogN) методом динамического программирования

## Решение задачи за O(N^2)

```java
import java.util.Arrays;

public class Main {
    // LIS - Longest Increasing Subsequence
    public static int findLIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n]; // Массив для хранения длин LIS
        int maxLIS = 1; // Максимальная длина LIS = 1,
        // так как каждый элемент это тоже последовательность длины 1

        Arrays.fill(dp, 1);
        // Инициализируем все элементы dp значением 1,
        // каждый элемент сам по себе является возрастающей подпоследовательностью длины

        // Находим LIS для каждого элемента в массиве
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // Если arr[i] больше arr[j], то значит мы можем продолжить предыдущую
                // возрастающую подпоследовательность, добавив arr[i] к ней.

                if (nums[i] > nums[j]) {
                    // Мы обновляем значение dp[i] путем выбора максимальной длины из
                    // dp[j] + 1 (длина предыдущей подпоследовательности, к которой мы добавляем
                    // новый
                    // и текущего значения dp[i].
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                    // Находим максимальное значение в массиве dp
                    // Это длина наибольшей возрастающей подпоследовательности
                    maxLIS = Math.max(maxLIS, dp[i]);
                }
            }
        }

        return maxLIS;
    }

    public static void main(String[] args) {
        int[] nums = { 3, 1, 5, 2, 4, 6};
        int lisLength = findLIS(nums);
        System.out.println("Наибольшая возрастающая подпоследовательность: " + lisLength);
    }
}
```

## Решение задачи за O(NlogN)

```java
import java.util.*;

public class Main {

    public static int findLIS(int[] nums) {
        int n = nums.length;
        // создаем массив, в котором будем хранить нарастающие подпоследовательности
        List<Integer> tails = new ArrayList<>();
        tails.add(nums[0]); // добавляем первый элемент в массив
        for (int num : nums) {
            // выполняем бинарный поиск в массиве tails , чтобы найти позицию,
            // на которую можно вставить nums[i],
            // чтобы поддерживать возрастающую последовательность
            int index = Collections.binarySearch(tails, num);
            if (index < 0) {
                index = -(index + 1);
                if (index == tails.size()) {
                    tails.add(num); // если найденный индекс равен длине массива,
                    // то добавляем элемент в конец массива
                } else {
                    tails.set(index, num);
                    // В противном случае заменяем элемент в найденной позиции на nums[i]
                    // Это обновление приводит к созданию новой возрастающей подпоследовательности,
                    // более длинной или равной предыдущей.
                }
            }
        }
        return tails.size();
    }

    public static void main(String[] args) {
        int[] nums = { 3, 1, 5, 2, 4, 6 };
        int length = findLIS(nums);
        System.out.println("Length of Longest Increasing Subsequence: " + length);
    }
}
```

Объяснение строки

```java
index = -(index + 1);
```

Когда мы используем метод Collections.binarySearch(list, key), он возвращает индекс найденного элемента в списке, если элемент присутствует.

Если элемент не найден, метод возвращает **отрицательное значение**, которое представляет **"точку вставки"** - место, где элемент должен быть вставлен, чтобы сохранить порядок сортировки списка.

В нашем случае, если index отрицателен, мы хотим получить "точку вставки" для текущего элемента num в список lis. Чтобы получить правильный индекс, мы применяем формулу

```python
-(index + 1)
```

В результате это даст нам положительное значение, представляющее индекс элемента, перед которым мы хотим вставить текущий элемент.

# 7. Задача поиска длины наибольшей общей подпоследовательности двух строк. Решение за O(n\*m) методом динамического программирования

```java
public class Main {
    // LCS - Longest Common Subsequence
    public static int findLCSLength(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();

        // Создаем двумерный массив dp размером (n+1) x (m+1).
        // dp[i][j] - длина наибольшей общей подпоследовательности для подстрок
        // s1[0:i] и s2[0:j]

        int[][] dp = new int[m + 1][n + 1];

        // Инициализируем первую строку и первый столбец массива dp нулями
        // При пустых подстроках длина наибольшей общей подпоследовательности равна 0
        for (int i = 0; i <= m; i++) {
            dp[i][0] = 0;
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = 0;
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // Если s1[i-1] равно s2[j-1]
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    // добавляем 1 к длине наибольшей общей подпоследовательности
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                    // выбираем максимальную длину наибольшей общей подпоследовательности
                }
            }
        }

        return dp[m][n];
    }

    public static void main(String[] args) {
        String str1 = "ABCDGH";
        String str2 = "AEDFHR";

        int lcsLength = findLCSLength(str1, str2);
        System.out.println("Length of Longest Common Subsequence: " + lcsLength);
    }
}

```

# 10. Алгоритм Форда-Беллмана. Описание алгоритма. Оценка времени выполнения

```java
import java.util.*;

public class Main {
    private static class Edge {
        private int dest;
        private int weight;

        public Edge(int dest, int weight) {
            this.dest = dest;
            this.weight = weight;
        }

        public int getDest() {
            return dest;
        }

        public int getWeight() {
            return weight;
        }
    }

    private static Map<Integer, List<Edge>> graph;
    private static int numVertices;

    public static void bellmanFord(int startVertex) {
        int[] distance = new int[numVertices + 1]; // создаем массив расстояний
        Arrays.fill(distance, Integer.MAX_VALUE); // заполняем его бесконечностями
        distance[startVertex] = 0; // расстояние до начальной вершины равно 0

        // проходим по всем ребрам
        for (int i = 0; i < numVertices - 1; i++) {
            for (int j = 1; j <= numVertices; j++) {
                // рассматриваем все ребра, исходящие из вершины j
                List<Edge> edges = graph.get(j);
                for (Edge edge : edges) {
                    int u = j; // начальная вершина
                    int v = edge.getDest(); // конечная вершина
                    int weight = edge.getWeight(); // вес между вершинами u и v
                    if (distance[u] != Integer.MAX_VALUE
                            && distance[u] + weight < distance[v]) {
                        // если расстояние существует
                        // и расстояние до вершины v больше,
                        // чем расстояние до вершины u + вес ребра (u, v)

                        // обновляем расстояние до вершины v
                        distance[v] = distance[u] + weight;
                    }

                }
            }
        }
        // проверка на отрицательный цикл
        for (int i = 1; i <= numVertices; i++) {
            List<Edge> edges = graph.get(i);
            for (Edge edge : edges) {
                int u = i;
                int v = edge.getDest();
                int weight = edge.getWeight();
                // Если мы можем улучшить расстояние до вершины v через вершину u,
                // то это означает наличие отрицательного цикла в графе
                if (distance[u] != Integer.MAX_VALUE && distance[u] + weight < distance[v]) {
                    throw new RuntimeException("Граф содержит отрицательный цикл!");
                }
            }
        }

        System.out.println("Расстояния до всех вершин:");
        for (int i = 1; i <= numVertices; i++) {
            System.out.println("Вершина " + i + ": " + distance[i]);
        }
    }

    public static void main(String[] args) {
        graph = new HashMap<>();
        numVertices = 4;

        // Добавление вершин и ребер в граф
        for (int i = 1; i <= numVertices; i++) {
            graph.put(i, new ArrayList<>());
        }

        addEdge(1, 2, 5);
        addEdge(1, 3, 10);
        addEdge(2, 3, 3);
        addEdge(3, 4, 1);

        int startVertex = 1;
        bellmanFord(startVertex);
    }

    private static void addEdge(int src, int dest, int weight) {
        graph.get(src).add(new Edge(dest, weight));
    }
}
```

# 11. Алгоритм Флойда-Уоршелла. Описание алгоритма. Оценка времени выполнения

## Алгоритм Флойда-Уоршелла

```java
import java.util.Arrays;
import java.util.ArrayList;

public class Main {
    private static final int INF = Integer.MAX_VALUE;

    public static void floydWarshall(int[][] graph) {
        int n = graph.length;

        int[][] dist = new int[n][n]; // Квадратная матрица кратчайших расстояний

        // Изначально dist[i][j] равно весу ребра ij
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }

        // заполняем матрицу расстояний из графа
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = graph[i][j];
            }
        }

        // находим кратчайший путь между каждой парой вершин через промежуточную вершину
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE
                            && dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }

        // выводим матрицу расстояний
        printSolution(dist);
    }

    // метод для вывода матрицы расстояний
    public static void printSolution(int[][] dist) {
        int n = dist.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][j] == Integer.MAX_VALUE) {
                    System.out.print("! ");
                } else {
                    System.out.print(dist[i][j] + " ");
                }
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[][] graph = {
                { 0, 5, INF, 10 },
                { INF, 0, 3, INF },
                { INF, INF, 0, 1 },
                { INF, INF, INF, 0 }
        };

        floydWarshall(graph);
    }
}
```

### Тройной цикл

Тройной цикл позволяет обойти все вершины графа и перебрать все возможные пути от каждой вершины до каждой вершины

```java
for (int k = 0; k < n; k++) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // код
        }
    }
}
```

Рассмотрим каждую итерацию:

1. На первой итерации (k=0), мы перебираем все возможные пары вершин i и j, и обновляем информацию о длине пути от i до j, если существует путь от i до j через вершину 0.
2. На второй итерации (k=1), мы перебираем все возможные пары вершин i и j, и обновляем информацию о длине пути от i до j, если существует путь от i до j через вершину 0 или 1.
3. На k-й итерации (k>1), мы перебираем все возможные пары вершин i и j, и обновляем информацию о длине пути от i до j, если существует путь от i до j через любую из вершин от 0 до k-1.

Таким образом, на каждой итерации мы рассматриваем все возможные пути от i до j через вершину k. В следующем разделе мы рассмотрим, как определить минимальные путь от i до j через k.

### Проверка на наличие меньшего пути

Эта строка кода проверяет, может ли путь от вершины i до вершины j быть улучшен при проходе через вершину k.

```java
if (dist[i][k] != Integer.MAX_VALUE
        && dist[k][j] != Integer.MAX_VALUE
        && dist[i][k] + dist[k][j] < dist[i][j]) {

    dist[i][j] = dist[i][k] + dist[k][j];
}
```

- dist[i][k] - расстояние от вершины i до вершины k
- dist[k][j] - расстояние от вершины k до вершины j
- dist[i][j]- текущее расстояние между вершинами i и j.

Если расстояние между i и k, и между k и j не равно бесконечности, то значит есть путь от i до k и от k до j соответственно. Тогда мы можем проверить, улучшит ли добавление вершины k текущий путь.

Если расстояние от от i до j через нынешний k меньше текущего расстояния между i и j, то мы можем обновить dist[i][j] с новым, более коротким путем через вершину k.

Если не нашлось пути через k, то значение dist[i][j] не изменится.

# 12. Двоичные деревья поиска. Описание структуры. Операции: построение, удаление, вставка. Асимптотика операций

## Класс узла дерева

```java
class Node {
    int key; // ключ узла
    Object value; // значение узла
    Node left; // ссылка на левый узел
    Node right; // ссылка на правый узел

    // в конструкторе указываем только id и значение
    public Node(int key, Object value) {
        this.key = key;
        this.value = value;
    }
}
```

## Основание класса дерева

```java
public class BinarySearchTree {
    Node root; // корневой узел дерева

    // конструктор создает пустое дерево
    public BinarySearchTree() {
        root = null;
    }

}
```

## Операции бинарного дерева

Все методы записываются в класс BinarySearchTree

### Добавление узла

```java
// метод добавления узла в дерево
    public void insert(int key, Object value) {
        Node newNode = new Node(key, value); // создаем объект узла
        if (root == null) { // если дерево пустое, новый узел становится корневым
            root = newNode;
            return;
        }
        // будем сравнивать новый узел с родительскими узлами
        Node current = root;
        Node parent;
        while (true) {
            parent = current;  // вначале родитель - корень,
            // потом будем двигаться вниз по дереву
            // если ключ добавляемого узла меньше текущего узла, переходим к левому поддереву
            if (key < current.key) {
                // если ключ меньше текущего родителя, идем налево
                current = current.left; // текущий узел становится левым потомком
                if (current == null) {
                    // если достигли конца левой ветки, добавляем новый узел
                    parent.left = newNode; // это ребенок родителя,
                    // которого мы еще не переписали
                    // добавили новый узел, уходим
                    return;

                }
            // если ключ добавляемого узла больше текущего узла, переходим к правому поддереву
            } if (key > current.key) {
                current = current.right; // текущий узел становится правым потомком
                if (current == null) {
                    // если достигли конца правой ветки, добавляем новый узел
                    parent.right = newNode;
                    return;
                }
            }
            else {
                // ключ добавляемого узла равен ключу текущего узла,
                // заменяем значение текущего узла
                current.value = value;
                return;
            }

        }
    }

```

### Удаление узла

```java
public class BinarySearchTree {
    private Node root; // ссылка на корень дерева

    // ...

    public boolean delete(int key) {
        // Если дерево пустое, удаление невозможно
        if (root == null) {
            return false;
        }

        // Найти узел с заданным ключом
        Node nodeToDelete = findNode(key, root);

        // Если узел не найден, удаление невозможно
        if (nodeToDelete == null) {
            return false;
        }

        // Если удаляемый узел не имеет дочерних узлов - удаляем лист
        if (nodeToDelete.left == null && nodeToDelete.right == null) {
            // Если удаляемый узел - корень дерева, то дерево становится пустым
            if (nodeToDelete == root) {
                root = null;
            }
            // Если удаляемый узел является левым потомком родителя
            else if (nodeToDelete == nodeToDelete.parent.left) {
                // теперь родитель ни на что не ссылается влево
                nodeToDelete.parent.left = null;
            }
            // Если удаляемый узел является правым потомком родителя
            else if (nodeToDelete == nodeToDelete.parent.right) {
                // теперь родитель ни на что не ссылается вправо
                nodeToDelete.parent.right = null;
            }
        }

        // Если удаляемый узел имеет только одного потомка
        else if (nodeToDelete.left == null || nodeToDelete.right == null) {
            // child  - левый или правый поток в зависимости от существования
            Node child =
            nodeToDelete.left != null ? nodeToDelete.left : nodeToDelete.right;

            // переписывание родителя ребенка удаляемого зла
            child.parent = nodeToDelete.parent;

            // Если удаляемый узел - корень дерева, то потомок становится корнем дерева
            if (nodeToDelete == root) {
                root = child;
            }
            // Если удаляемый узел является левым потомком родителя
            else if (nodeToDelete == nodeToDelete.parent.left) {
                // теперь родитель удаляемого ссылается на на потомка
                nodeToDelete.parent.left = child;
                // на удаляемый элемент никто не ссылается - его не существует
            }
            // Если удаляемый узел является правым потомком родителя
            else if  (nodeToDelete == nodeToDelete.parent.right) {
                nodeToDelete.parent.right = child;
            }
        }

        // Если удаляемый узел имеет двух потомков
        else {
            // Найти наименьший узел в правом поддереве
            Node minRight = nodeToDelete.right;
            // то есть опускаемся "влево" - там наименьший
            while (minRight.left != null) {
                minRight = minRight.left;
            }

            // Заменить удаляемый узел на наименьший узел в правом поддереве
            nodeToDelete.key = minRight.key;
            nodeToDelete.value = minRight.value;

            // Удалить наименьший узел в правом поддереве
            if (minRight == nodeToDelete.right) {
                // Если найденный минимум - прямой потомок, то мы заменяем ссылки
                nodeToDelete.right = minRight.right;
                // теперь удаленный ни на что не ссылается
            } else {
                // Если минимальный узел не является прямым потомком удаляемого узла, мы заменяем его ссылку на ссылку на правый потомок минимального узла. Это происходит для того, чтобы сохранить свойство BST, где правый потомок всегда больше текущего узла, а левый - меньше. Если мы бы просто удалили минимальный узел, то это свойство бы нарушилось, поэтому мы заменяем его на правый потомок.
                minRight.parent.left = minRight.right;
            }
        }

        return true;
    }

}
```

### Поиск по ключу

Воспользуемся рекурсией для этого алгоритма

```java
public Node findNode(int key, Node rootNode) {
    // если узел пуст, значит ключ не найден
    if (rootNode == null) {
        return null;
    }

    // если ключ текущего узла равен искомому, возвращаем этот узел
    if (rootNode.key == key) {
        return node;
    }

    // если искомый ключ меньше ключа текущего узла, ищем в левом поддереве
    if (key < rootNode.key) {
        return search(key, rootNode.left);
    }

    // иначе ищем в правом поддереве
    return search(key, rootNode.right);
}
```

### Нахождение предыдущего элемента

Найти в бинарном дереве поиска узла **с максимальным ключом, который меньше, чем заданный ключ**

```java
public Node findPredecessor(Node node) {
    if (node.left != null) {
        // если узел имеет левого потомка, то следующий узел находится в его левом поддереве
        node = node.left;
        while (node.right != null) {
            // идем по всем правым потомкам, пока не найдем узел без правых потомков
            node = node.right;
        }
        return node;
    } else {
        // если узел не имеет левого потомка, то следующий узел находится в родительском узле
        Node parent = node.parent;
        while (parent != null && node == parent.left) {
            // если значение ключа текущего узла равно заданному ключу, то нам нужно найти предыдущий узел относительно этого ключа
            node = parent; // узел становится родительским
            parent = parent.parent; // поднимаемся вверх на один уровень
        }
        return parent;
    }
}
```

### Нахождение следующего элемента

Найти в бинарном дереве поиска узел **с минимальным ключом, который больше, чем заданный ключ**

```java
public Node findSuccessor(Node node) {
    if (node.right != null) {
        // если узел имеет правого потомка, то следующий узел находится в его правом поддереве
        node = node.right;
        while (node.left != null) {
            // идем по всем левым потомкам, пока не найдем узел без левых потомков
            node = node.left;
        }
        return node;
    } else {
        // если узел не имеет правого потомка, то следующий узел находится в родительском узле
        Node parent = node.parent;
        while (parent != null && node == parent.right) {
             // если значение ключа текущего узла равно заданному ключу, то нам нужно найти следующий узел относительно этого ключа
            node = parent; // узел становится родительским
            parent = parent.parent; // поднимаемся вверх на один уровень
        }
        return parent;
    }
}
```

## Обход элементов дерева

### Прямой

```java
public void preOrderTraversal(Node node) {
    if (node == null) {
        return;
    }

    // посетить текущий узел
    System.out.print(node.key + " ");

    // рекурсивно обойти левое поддерево
    preOrderTraversal(node.left);

    // рекурсивно обойти правое поддерево
    preOrderTraversal(node.right);
}
```

### Симметричный

```java
public void inOrderTraversal(Node node) {
    if (node == null) {
        return;
    }

    inOrderTraversal(node.left);
    System.out.print(node.value + " ");
    inOrderTraversal(node.right);

}

```

### Обратный

```java
public void traversePostOrder(Node node) {
    if (node != null) {
        traversePostOrder(node.right); // обход правого поддерева
        traversePostOrder(node.left); // обход левого поддерева
        System.out.print(node.value + " "); // обработка текущего узла
    }
}
```

## Нахождение минимума и максимума

```java
public Node findMin(Node node) {
    if (node == null) {
        return null; // если дерево пустое, вернуть null
    }
    while (node.left != null) {
        node = node.left; // идем влево до тех пор, пока не найдем узел без левого потомка
    }
    return node; // возвращаем найденный узел
}
```
