# 1. Хеширование. Полиномиальная функция. Алгоритм Рабина-Карпа. Оценка времени выполнения функции

## Использование полиномиальной функции для хеширования. Алгоритм Рабина-Карпа

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    private static final int PRIME = 101; // задаем простое число для хэша

    public static List<Integer> search(String text, String pattern) {
        // в списке храним все значения
        List<Integer> occurrences = new ArrayList<>();

        int patternHash = calculateHash(pattern); // создаем хэш для паттерна
        int textHash = calculateHash(text.substring(0, pattern.length()));
        // первое "окно" для проверки начинается с нулевого индекса

        // цикл продолжается до тех пор, пока не будут проверены все окна
        // при каждом сдвиге окно переносится на 1
        for (int i = 0; i <= text.length() - pattern.length(); i++) {
            // если текущий хэш совпадает с искомым
            if (textHash == patternHash) {
                // если верно, то проверяем на коллизию
                if (text.substring(i, i + pattern.length()).equals(pattern)) {
                    occurrences.add(i);
                }
            }

            // Если i меньше чем разница длины text и pattern,
            // мы пересчитываем хэш для следующей итерации цикла.
            // Мы делаем это, удаляя первый предыдущий символ и добавляя следующий.
            // переходим к следующему окну размером pattern.length() в тексте
            if (i < text.length() - pattern.length()) {
                textHash = calculateHash(text.substring(i + 1, i + pattern.length() + 1));
            }
        }

        return occurrences;
    }

    // вычисляем хэш для строки в виде итт-значения
    private static int calculateHash(String str) {
        int hash = 0;
        for (int i = 0; i < str.length(); i++) {
            // hash = (s[0] * p^(n-1)) + (s[1] * p^(n-2)) + ... + (s[n-1] * p^0),
            // s = str.charAt(i) - числовое значение символа
            // p = PRIME - выбранное простое число
            // n = str.length() - длина последовательности символа
            hash += str.charAt(i) * Math.pow(PRIME, str.length() - i - 1);

        }
        return hash;
    }

    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABDABACDABABCABAB";
        List<Integer> occurrences = search(text, pattern);
        if (occurrences.isEmpty()) {
            System.out.println("Pattern not found in the text");
        } else {
            System.out.println("Pattern found at positions: " + occurrences);
        }
    }
}

```

# 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2+E). Улучшение алгоритма для разреженных графов за O(E\*logV)

// TODO добавить обычный алгоритм

## Алгоритм за O(V^2+E)

В этой реализации граф представлен в виде матрицы смежности adjacencyMatrix, где adjacencyMatrix[i][j] представляет собой вес ребра между вершинами i и j. Значение 0 указывает на отсутствие ребра между вершинами.

```java
import java.util.Arrays;

class DijkstraAlgorithm {
    private int V; // число вершин
    private int[][] graph; // граф в виде матрицы смежности

    public DijkstraAlgorithm(int[][] adjacencyMatrix) {
        this.V = adjacencyMatrix.length;
        this.graph = adjacencyMatrix;
    }

    public int[] shortestPath(int source) {

        int[] distance = new int[V]; // создаем массив с расстояниями
        boolean[] visited = new boolean[V]; // создаем пустое множество посещенных вершин

        Arrays.fill(distance, Integer.MAX_VALUE); // всем назначаем "бесконечность"
        distance[source] = 0; // начальная вершина, значение равно нулю

        for (int i = 0; i < V - 1; i++) {
            int minVertex = findMinDistanceVertex(distance, visited);
            visited[minVertex] = true; // помеченную вершину посещаем

            // обновляем расстояния для всех смежных вершин
            // Если новое расстояние до соседней вершины меньше текущего расстояния,
            // то обновляем его
            for (int j = 0; j < V; j++) {
                if (!visited[j]
                        && graph[minVertex][j] != 0
                        && distance[minVertex] != Integer.MAX_VALUE
                        && distance[minVertex] + graph[minVertex][j] < distance[j]) {
                    // вершина j еще не была посещена, между вершинами
                    // minVertex и j существует ребро,
                    // расстояние до minVertex не является бесконечностью
                    // новое расстояние через minVertex до j меньше текущего
                    distance[j] = distance[minVertex] + graph[minVertex][j];
                    // обновляем расстояние
                }
            }
        }

        return distance;
    }

    private int findMinDistanceVertex(int[] distance, boolean[] visited) {
        int minDistance = Integer.MAX_VALUE;
        int minVertex = -1;

        for (int i = 0; i < V; i++) {
            // если ранее не посещена и расстояние меньше
            if (!visited[i] && distance[i] < minDistance) {
                minDistance = distance[i]; // присваиваем минимальное расстояние
                minVertex = i; // возвращаем id вершины, на которую скоро перейдем
            }
        }

        return minVertex;
    }
}

public class Main {
    public static void main(String[] args) {
        int[][] adjacencyMatrix = {
                { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
                { 4, 0, 8, 0, 0, 0, 0, 11, 0 },
                { 0, 8, 0, 7, 0, 4, 0, 0, 2 },
                { 0, 0, 7, 0, 9, 14, 0, 0, 0 },
                { 0, 0, 0, 9, 0, 10, 0, 0, 0 },
                { 0, 0, 4, 14, 10, 0, 2, 0, 0 },
                { 0, 0, 0, 0, 0, 2, 0, 1, 6 },
                { 8, 11, 0, 0, 0, 0, 1, 0, 7 },
                { 0, 0, 2, 0, 0, 0, 6, 7, 0 }
        };

        int source = 0;

        DijkstraAlgorithm dijkstra = new DijkstraAlgorithm(adjacencyMatrix);
        int[] shortestDistances = dijkstra.shortestPath(source);

        System.out.println("Shortest distances from source vertex " + source + ":");
        for (int i = 0; i < shortestDistances.length; i++) {
            System.out.println("Vertex " + i + ": " + shortestDistances[i]);
        }
    }
}
```

## Алгоритм для разреженных графов за O(E\*logV)

```java
import java.util.*;

public class Main {

    public static int[] dijkstra(int[][] graph, int startVertex) {
        int n = graph.length;
        boolean[] visited = new boolean[n];

        // создаем множество с расстояниями, все расстояния временно помечаем как
        // бесконечность
        int[] distances = new int[n];
        Arrays.fill(distances, Integer.MAX_VALUE);
        // расстояние стартовой вершины равно 0
        distances[startVertex] = 0;
        visited[startVertex] = true;
        // создаем пустую минимальную кучу, которая принимает непосещенные вершины
        PriorityQueue<Node> pq = new PriorityQueue<>(n, new Node());
        pq.add(new Node(startVertex, 0)); // добавляем начальную вершину
        // перебираем кучу
        while (!pq.isEmpty()) {
            // Извлекаем вершину с наименьшим текущим расстоянием из приоритетной очереди
            // используя siftDown
            Node currentNode = pq.poll();
            int currentVertex = currentNode.vertex;
            int currentDistance = currentNode.distance;
            visited[currentVertex] = true; // посещаем вершину

            // рассматриваем всех соседей посещенной вершины
            for (int neighbor = 0; neighbor < n; neighbor++) {
                // weight[i][j] - расстояние между i и j
                int weight = graph[currentVertex][neighbor];
                if (weight > 0 && !visited[neighbor]) {
                    int distance = currentDistance + weight; // вычисляем расстояние
                    // если расстояние меньше, чем текущее расстояние
                    if (distance < distances[neighbor]) {
                        distances[neighbor] = distance; // обновляем расстояние
                        pq.add(new Node(neighbor, distance)); // добавляем вершину в кучу
                    }
                }
            }
        }

        return distances;
    }

    public static void main(String[] args) {
        int[][] graph = {
                { 0, 10, 5, 0, 0 },
                { 0, 0, 0, 3, 0 },
                { 0, 2, 0, 9, 0 },
                { 0, 0, 0, 0, 2 },
                { 0, 0, 1, 0, 0 }
        };

        int startVertex = 0;
        int[] distances = dijkstra(graph, startVertex);
        System.out.println(Arrays.toString(distances));
    }

    // используем компаратор для того,
    // чтобы на верху кучи были вершины с наименьшим расстоянием
    static class Node implements Comparator<Node> {
        public int vertex;
        public int distance;

        public Node() {
        }

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        public int compare(Node node1, Node node2) {
            if (node1.distance < node2.distance) {
                return -1;
            }
            if (node1.distance > node2.distance) {
                return 1;
            }
            return 0;
        }
    }
}
```

# 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке.

## Задача о кузнечике

```java
public int countWays(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0; // на нулевую клетку он не может попасть
    dp[1] = 1; // до первой клетки есть единственный способ допрыгнуть - совершить прыжок длиной 1
    dp[2] = 2; // до второй клетки можно прыгнуть за один прыжок длиной 2, либо за два прыжка длиной 1
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]; //кузнечик может прыгнуть на текущую позицию либо из позиции i - 1, либо из позиции i -  2
        // чтобы достичь позиции i, кузнечику необходимо достичь позиции i - 1
        //  затем есть два варианта
        // 1. сделать последний прыжок на одну ступеньку, ИЛИ
        // 2. достичь позиции i - 2 и сделать последний прыжок на две ступеньки. Таким образом, решение задачи сводится к нахождению оптимальных решений подзадач для позиций i - 1 и i - 2.
    }
    return dp[n];
}
```

## Задача о черепашке

```java
public class TurtlePath {
    public static int minPathCost(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;

        int[][] dp = new int[rows][cols];
        dp[0][0] = grid[0][0];

        // Инициализация первой строки
        // В первой строке мы можем двигаться только вправо
        // Поэтому прибавляем предыдущие значения слева
        for (int j = 1; j < cols; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }

        // Инициализация первого столбца
        // В первом столбце двигаемся вниз, прибавляем "верхние значения"
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }

        // Вычисление минимальной стоимости достижения каждой ячейки
        // Начинаем i и j с единицы, так как первые строку и столбец уже проработали
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                // min - для выбора оптимального пути
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }

        return dp[rows-1][cols-1];
    }

    public static void main(String[] args) {
        int[][] grid = {
            {1, 3, 1},
            {1, 5, 1},
            {4, 2, 1}
        };

        int minCost = minPathCost(grid);
        System.out.println("Минимальная стоимость достижения конечной позиции: " + minCost);
    }
}
```

    
```java
public class Main {
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];

        // начинаем с 1, это минимальный id предмета и вместимость рюкзака
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= capacity; j++) {
                // получаем доступ к весу текущего через weights[i - 1]
                if (weights[i - 1] <= j) {
                    // выбираем максимальную стоимость
                    // 1. Включаем предмет через формулу, сложив нынешнюю и старую цену
                    // 2. Не включаем предмет
                    dp[i][j] = Math.max(values[i - 1] + dp[i - 1][j - weights[i - 1]],
                            dp[i - 1][j]);
                    // если вес предмета меньше текущей вместимости
                } else {
                    // пропускаем предмет
                    // оставляем значение dp[i][j] равным значению dp[i-1][j]
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[n][capacity];
    }

    public static void main(String[] args) {
        int[] weights = { 2, 3, 5, 7 };
        int[] values = { 10, 15, 25, 30 };
        int capacity = 10;

        int maxProfit = knapsack(weights, values, capacity);
        System.out.println("Max Profit: " + maxProfit);
    }
}
```

## 10. Алгоритм Форда-Беллмана. Описание алгоритма. Оценка времени выполнения

```java
public void bellmanFord(int startVertex) {
    // Инициализируем расстояние до всех вершин бесконечностью, кроме стартовой вершины
    int[] distance = new int[getNumVertices()];
    Arrays.fill(distance, Integer.MAX_VALUE);
    distance[startVertex] = 0;



    // Проходим по всем ребрам V-1 раз и обновляем расстояния до вершин
    for (int i = 0; i < getNumVertices() - 1; i++) {
        for (int j = 1; j <= getNumVertices(); j++) {
            List<Edge> edges = getEdges(j);
            for (Edge edge : edges) {
                int u = j;
                int v = edge.getDest();
                int weight = edge.getWeight();
                if (distance[u] != Integer.MAX_VALUE && distance[u] + weight < distance[v]) {
                    distance[v] = distance[u] + weight;
                }
            }
        }
    }

            // Проверяем наличие отрицательных циклов
    for (int i = 1; i <= getNumVertices(); i++) {
        List<Edge> edges = getEdges(i);
        for (Edge edge : edges) {
            int u = i;
            int v = edge.getDest();
            int weight = edge.getWeight();
            if (distance[u] != Integer.MAX_VALUE && distance[u] + weight < distance[v]) {
                throw new RuntimeException("Граф содержит отрицательный цикл!");
            }
        }
    }



    // Выводим результаты
    System.out.println("Расстояния до всех вершин:");
    for (int i = 1; i <= getNumVertices(); i++) {
        System.out.println("Вершина " + i + ": " + distance[i]);
    }
}
```
