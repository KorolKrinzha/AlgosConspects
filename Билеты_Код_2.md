# 3. Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2+E). Улучшение алгоритма для разреженных графов за O(E\*logV)

// TODO добавить обычный алгоритм

## Алгоритм для разреженных графов за O(E\*logV)

```java
import java.util.*;

public class DijkstraAlgorithm {
    public static void main(String[] args) {
        Map<Integer, List<Edge>> graph = new HashMap<Integer, List<Edge>>();

        // добавление вершин и ребер в граф
        // ...

        int startVertex = 1; // начальная вершина для поиска кратчайшего пути
        int[] distances = dijkstra(graph, startVertex);
        System.out.println(Arrays.toString(distances)); // печать массива кратчайших расстояний от startVertex до остальных вершин
    }

    public static int[] dijkstra(Map<Integer, List<Edge>> graph, int startVertex) {
        int n = graph.size();
        int[] distances = new int[n+1];
        Arrays.fill(distances, Integer.MAX_VALUE); // по аналогии с бесконечность, бесконечность, бесконечность...
        distances[startVertex] = 0; // мы уже там, где начальная вершина. Расстояние равно 0
        PriorityQueue<Node> pq = new PriorityQueue<Node>(n, new Node()); // создание хранилища для вершин графа, которые еще не были посещены.

        // добавляем начальную вершину в очередь - начинаем с нее
        pq.add(new Node(startVertex, 0));

        // обходим граф
        while (!pq.isEmpty()) {
            // берем вершину с наименьшим расстоянием
            Node currentNode = pq.poll();
            int currentVertex = currentNode.vertex;
            int currentDistance = currentNode.distance;

            // проверяем все смежные вершины - достаем list по id currentVertex
            List<Edge> edges = graph.get(currentVertex);
            if (edges != null) {
                for (Edge edge : edges) {
                    int neighbor = edge.neighbor;
                    int weight = edge.weight;
                    int distance = currentDistance + weight;

                    if (distance < distances[neighbor]) {
                        // если найден более короткий путь, обновляем кратчайшее расстояние и добавляем вершину в очередь
                        distances[neighbor] = distance;
                        pq.add(new Node(neighbor, distance));
                    }
                }
            }
        }

        return distances;
    }

    // имплементируем компаратор, чтобы можно было сравнивать node
    // и распределять их по приоритету
    static class Node implements Comparator<Node> {
        public int vertex; // значение вершины
        public int distance; // текущее расстояние

        public Node() {}

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        // Метод статического класса. Сравнивает две вершины по их расстояниям
        public int compare(Node node1, Node node2) {
            if (node1.distance < node2.distance) {
                return -1;
            }
            if (node1.distance > node2.distance) {
                return 1;
            }
            return 0;
        }
    }


    // реализация ребра, которую мы обсудили ранее
    static class Edge {
        public int neighbor;
        public int weight;

        public Edge() {}

        public Edge(int neighbor, int weight) {
            this.neighbor = neighbor;
            this.weight = weight;
        }
    }
}
```

# 4. Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке.

## Задача о кузнечике

```java
public int countWays(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0; // на нулевую клетку он не может попасть
    dp[1] = 1; // до первой клетки есть единственный способ допрыгнуть - совершить прыжок длиной 1
    dp[2] = 2; // до второй клетки можно прыгнуть за один прыжок длиной 2, либо за два прыжка длиной 1
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]; //кузнечик может прыгнуть на текущую позицию либо из позиции i - 1, либо из позиции i -  2
        // чтобы достичь позиции i, кузнечику необходимо достичь позиции i - 1
        //  затем есть два варианта
        // 1. сделать последний прыжок на одну ступеньку, ИЛИ
        // 2. достичь позиции i - 2 и сделать последний прыжок на две ступеньки. Таким образом, решение задачи сводится к нахождению оптимальных решений подзадач для позиций i - 1 и i - 2.
    }
    return dp[n];
}
```

## Задача о черепашке

```java
public class TurtlePath {
    public static int minPathCost(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;

        int[][] dp = new int[rows][cols];
        dp[0][0] = grid[0][0];

        // Инициализация первой строки
        // В первой строке мы можем двигаться только вправо
        // Поэтому прибавляем предыдущие значения слева
        for (int j = 1; j < cols; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }

        // Инициализация первого столбца
        // В первом столбце двигаемся вниз, прибавляем "верхние значения"
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }

        // Вычисление минимальной стоимости достижения каждой ячейки
        // Начинаем i и j с единицы, так как первые строку и столбец уже проработали
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                // min - для выбора оптимального пути
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }

        return dp[rows-1][cols-1];
    }

    public static void main(String[] args) {
        int[][] grid = {
            {1, 3, 1},
            {1, 5, 1},
            {4, 2, 1}
        };

        int minCost = minPathCost(grid);
        System.out.println("Минимальная стоимость достижения конечной позиции: " + minCost);
    }
}
```

```java
public class Main {
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];

        // начинаем с 1, это минимальный id предмета и вместимость рюкзака
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= capacity; j++) {
                // получаем доступ к весу текущего через weights[i - 1]
                if (weights[i - 1] <= j) {
                    // выбираем максимальную стоимость
                    // 1. Включаем предмет через формулу, сложив нынешнюю и старую цену
                    // 2. Не включаем предмет
                    dp[i][j] = Math.max(values[i - 1] + dp[i - 1][j - weights[i - 1]],
                            dp[i - 1][j]);
                    // если вес предмета меньше текущей вместимости
                } else {
                    // пропускаем предмет
                    // оставляем значение dp[i][j] равным значению dp[i-1][j]
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[n][capacity];
    }

    public static void main(String[] args) {
        int[] weights = { 2, 3, 5, 7 };
        int[] values = { 10, 15, 25, 30 };
        int capacity = 10;

        int maxProfit = knapsack(weights, values, capacity);
        System.out.println("Max Profit: " + maxProfit);
    }
}
```
