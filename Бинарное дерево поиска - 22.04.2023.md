# Бинарное дерево поиска

Бинарное дерево поиска - это структура данных, представляющая собой дерево, где каждый узел содержит ключ и два поддерева, левое и правое, каждое из которых также является бинарным деревом поиска.

```
      8
   /    \
  3     10
 / \    / \
 1  6      14
 /\/ \     / \
   4  7   13
```

### Условия бинарного дерева поиска

Все элементы **левого** поддерева должны быть **меньше текущего элемента**

Все элементы **правого** поддерева должна быть **больше текущего элемента**

## Использование

Бинарное дерево поиска используется для хранения и быстрого поиска данных, основываясь на принципе **сортировки элементов в дереве**. Оно позволяет хранить упорядоченный набор элементов

Одной из главных особенностей бинарного дерева поиска является то, что элементы хранятся **в упорядоченном виде**. Это позволяет выполнять операции поиска, **вставки и удаления элементов из дерева** за оптимальное время

## Операции с бинарным деревом

- Поиск элемента по ключу
- Вставка нового элемента в дерево
- Удаление элемента из дерева
- Обход элементов дерева
  - прямой (pre-order)
  - симметричный (in-order)
  - обратный (post-order)

## Реализация на Java

Бинарное дерево поиска можно реализовать на Java с помощью класса, представляющего узел дерева. Каждый узел содержит ключ, значение и ссылки на его левое и правое поддеревья.

```java
class Node {
    int key; // ключ узла
    Object value; // значение узла
    Node left; // ссылка на левый узел
    Node right; // ссылка на правый узел

    // в конструкторе указываем только id и значение
    public Node(int key, Object value) {
        this.key = key;
        this.value = value;
    }
}
```

Создадим основу для класса бинарного дерева

```java
public class BinarySearchTree {
    Node root; // корневой узел дерева

    // конструктор создает пустое дерево
    public BinarySearchTree() {
        root = null;
    }

}
```

Последовательно рассмотрим, из каких операций состоит бинарное дерево поиска, и добавим операции в наш код.

### Добавление узла

1. Начинаем с корневого узла. Сравниваем ключ добавляемого узла со значением ключа текущего узла.
2. Если ключ добавляемого узла меньше текущего узла, переходим к левому поддереву.
3. Если ключ добавляемого узла больше текущего узла, переходим к правому поддереву.
4. Если соответствующего поддерева не существует, создаем его и добавляем новый узел.
5. Если ключ добавляемого узла равен ключу текущего узла, то заменяем значение текущего узла на значение добавляемого узла.

```java
    // метод добавления узла в дерево
    public void insert(int key, Object value) {
        Node newNode = new Node(key, value); // создаем новый узел
        if (root == null) { // если дерево пустое, новый узел становится корневым
            root = newNode;
            return;
        }
        // будем сравнивать новый узел с родительскими узлами
        Node current = root;
        Node parent;
        while (true) {
            parent = current;
            if (key < current.key) { // если ключ меньше текущего, идем налево
                current = current.left;
                if (current == null) {
                    // если достигли конца левой ветки, добавляем новый узел
                    parent.left = newNode;
                    // добавили новый узел, уходим
                    return;

                }
                // иначе идем направо
            } else {
                current = current.right;
                if (current == null) {
                    // если достигли конца правой ветки, добавляем новый узел
                    parent.right = newNode;
                    return;
                }
            }
        }
    }
```

Временная сложность добавления узла в бинарное дерево поиска зависит от высоты и устройства дерева. В худшем случае, когда дерево является линейным, сложность операции составляет O(n)

Пример линейного дерева

```rust
1 -> 2 -> 3 -> 4 -> 5 -> null
```

Если бы мы хотели добавить 6, то нам пришлось пройти через все элементы

В сбалансированном дереве, когда высота дерева log(n), сложность операции добавления узла составляет O(log(n)).

### Удаление узла

Алгоритм удаления узла из линейного дерева состоит из следующих шагов:

1. Начинаем с корневого узла и идем по дереву, пока не найдем узел, который нужно удалить. Если такого узла нет, то операция завершается без изменений.
2. Если найденный узел не имеет дочерних узлов, то он просто удаляется.
3. Если найденный узел имеет только одного потомка, то этот потомок заменяет удаляемый узел.
4. Если найденный узел имеет двух потомков, то нужно найти узел с наименьшим значением в правом поддереве удаляемого узла (чтобы сохранить свойство дерева - все остальные **в правой ветке** будут **больше родителя**). Этот узел заменит удаляемый узел, а потомки удаляемого узла станут потомками найденного узла.

Повторяем шаги 2-4 для нового узла, если он был заменен.

```java
public class BinarySearchTree {
    private Node root; // ссылка на корень дерева

    // ...

    public boolean delete(int key) {
        // Если дерево пустое, удаление невозможно
        if (root == null) {
            return false;
        }

        // Найти узел с заданным ключом
        Node nodeToDelete = findNode(key, root);

        // Если узел не найден, удаление невозможно
        if (nodeToDelete == null) {
            return false;
        }

        // Если удаляемый узел не имеет дочерних узлов - удаляем лист
        if (nodeToDelete.left == null && nodeToDelete.right == null) {
            // Если удаляемый узел - корень дерева, то дерево становится пустым
            if (nodeToDelete == root) {
                root = null;
            }
            // Если удаляемый узел является левым потомком родителя
            else if (nodeToDelete == nodeToDelete.parent.left) {
                // теперь родитель ни на что не ссылается влево
                nodeToDelete.parent.left = null;
            }
            // Если удаляемый узел является правым потомком родителя
            else if (nodeToDelete == nodeToDelete.parent.right) {
                // теперь родитель ни на что не ссылается вправо
                nodeToDelete.parent.right = null;
            }
        }

        // Если удаляемый узел имеет только одного потомка
        else if (nodeToDelete.left == null || nodeToDelete.right == null) {
            // child  - левый или правый поток в зависимости от существования
            Node child = nodeToDelete.left != null ? nodeToDelete.left : nodeToDelete.right;

            // переписывание родителя ребенка удаляемого зла
            child.parent = nodeToDelete.parent;

            // Если удаляемый узел - корень дерева, то потомок становится корнем дерева
            if (nodeToDelete == root) {
                root = child;
            }
            // Если удаляемый узел является левым потомком родителя
            else if (nodeToDelete == nodeToDelete.parent.left) {
                // теперь родитель удаляемого ссылается на на потомка
                nodeToDelete.parent.left = child;
                // на удаляемый элемент никто не ссылается - его не существует
            }
            // Если удаляемый узел является правым потомком родителя
            else if  (nodeToDelete == nodeToDelete.parent.right) {
                nodeToDelete.parent.right = child;
            }
        }

        // Если удаляемый узел имеет двух потомков
        else {
            // Найти наименьший узел в правом поддереве
            Node minRight = nodeToDelete.right;
            // то есть опускаемся "влево" - там наименьший
            while (minRight.left != null) {
                minRight = minRight.left;
            }

            // Заменить удаляемый узел на наименьший узел в правом поддереве
            nodeToDelete.key = minRight.key;
            nodeToDelete.value = minRight.value;

            // Удалить наименьший узел в правом поддереве
            if (minRight == nodeToDelete.right) {
                // Если найденный минимум - прямой потомок, то мы заменяем ссылки
                nodeToDelete.right = minRight.right;
                // теперь удаленный ни на что не ссылается
            } else {
                // Если минимальный узел не является прямым потомком удаляемого узла, мы заменяем его ссылку на ссылку на правый потомок минимального узла. Это происходит для того, чтобы сохранить свойство BST, где правый потомок всегда больше текущего узла, а левый - меньше. Если мы бы просто удалили минимальный узел, то это свойство бы нарушилось, поэтому мы заменяем его на правый потомок.
                minRight.parent.left = minRight.right;
            }
        }

        return true;
    }

}
```

Временная сложность: худший случай - O(n), средний случай - O(log n)

### Поиск по ключу

0. Поиск по ключу в бинарном дереве поиска начинается с корневого узла.
1. Если ключ, который мы ищем, равен ключу корневого узла, то мы нашли нужный узел и завершаем поиск.
2. Если ключ, который мы ищем, меньше ключа корневого узла, то мы продолжаем поиск в левом поддереве корневого узла.
3. Если ключ, который мы ищем, больше ключа корневого узла, то мы продолжаем поиск в правом поддереве корневого узла.

Воспользуемся рекурсией, чтобы написать этот алгоритм

```java
public Node findNode(int key, Node rootNode) {
    // если узел пуст, значит ключ не найден
    if (rootNode == null) {
        return null;
    }

    // если ключ текущего узла равен искомому, возвращаем этот узел
    if (rootNode.key == key) {
        return node;
    }

    // если искомый ключ меньше ключа текущего узла, ищем в левом поддереве
    if (key < rootNode.key) {
        return search(key, rootNode.left);
    }

    // иначе ищем в правом поддереве
    return search(key, rootNode.right);
}

```

В худшем случае, когда дерево является односторонним (линейным), время поиска будет линейным, O(n), где n - количество узлов в дереве. Однако, в сбалансированном бинарном дереве поиска, высота дерева будет O(log n), что приведет к временной сложности поиска O(log n) - это средняя временная сложность.

### Нахождение предыдущего элемента

Задание "найти предыдущий узел относительно заданного ключа" означает поиск в бинарном дереве поиска узла **с максимальным ключом, который меньше, чем заданный ключ**

1. Находим узел с заданным ключом с помощью алгоритма поиска по ключу.
2. Проверяем у искомого узла, есть ли у него **левый потомок**. Если есть, то переходим к этому потомку и затем идем вправо до тех пор, пока не дойдем до узла, у которого нет правого потомка (идем **"вниз вправо"**). Этот узел и будет предыдущим по отношению к искомому узлу.
3. Если у искомого узла нет левого потомка, то идем по всем родительским узлам до тех пор, пока текущий узел не станет левым потомком своего родителя ("поднимаемся влево"). Родитель этого узла и будет предыдущим по отношению к искомому узлу.

```java
public Node findPredecessor(Node node) {
    if (node.left != null) {
        // если узел имеет левого потомка, то следующий узел находится в его левом поддереве
        node = node.left;
        while (node.right != null) {
            // идем по всем правым потомкам, пока не найдем узел без правых потомков
            node = node.right;
        }
        return node;
    } else {
        // если узел не имеет левого потомка, то следующий узел находится в родительском узле
        Node parent = node.parent;
        while (parent != null && node == parent.left) {
            // если значение ключа текущего узла равно заданному ключу, то нам нужно найти предыдущий узел относительно этого ключа
            node = parent; // узел становится родительским
            parent = parent.parent; // поднимаемся вверх на один уровень
        }
        return parent;
    }
}
```

Временная сложность:

- Худший случай: O(n)
- Средний случай: O(log n)

### Нахождение следующего элемента

Задание "найти следующий узел относительно заданного ключа" означает поиск в бинарном дереве поиска узла **с минимальным ключом, который больше, чем заданный ключ**

Алгоритм поиска следующего узла по ключу в бинарном дереве поиска работает следующим образом:

1. Находим узел с заданным ключом с помощью алгоритма поиска по ключу.
2. Если **правое поддерево** найденного узла не пустое, то ищем в нём узел с минимальным ключом (то есть **"спускаемся влево"**). Это будет следующий узел по ключу.
3. Если правое поддерево пустое, то идём вверх по дереву, пока текущий узел является правым потомком своего родителя, и продолжаем поиск вверх по дереву до тех пор, пока не найдём первый узел, который является левым потомком своего родителя. (то есть "поднимаемся вправо") Его ключ будет следующим по порядку.

Реализация на java

```java
public Node findSuccessor(Node node) {
    if (node.right != null) {
        // если узел имеет правого потомка, то следующий узел находится в его правом поддереве
        node = node.right;
        while (node.left != null) {
            // идем по всем левым потомкам, пока не найдем узел без левых потомков
            node = node.left;
        }
        return node;
    } else {
        // если узел не имеет правого потомка, то следующий узел находится в родительском узле
        Node parent = node.parent;
        while (parent != null && node == parent.right) {
             // если значение ключа текущего узла равно заданному ключу, то нам нужно найти следующий узел относительно этого ключа
            node = parent; // узел становится родительским
            parent = parent.parent; // поднимаемся вверх на один уровень
        }
        return parent;
    }
}

```

Временная сложность:

- Худший случай: O(n)
- Средний случай: O(log n)

## Обход элементов дерева

### Прямой

Прямой обход дерева - это обход дерева, при котором сначала посещается корень дерева, затем левое поддерево и затем правое поддерево.

Для каждого узла в дереве алгоритм прямого обхода выполняет следующие операции:

1. Посещаем корневой узел
2. Рекурсивно посещаем левое поддерево, выполняя обход для его корневого узла
3. Рекурсивно посещаем правое поддерево, выполняя обход для его корневого узла

```java
public void preOrderTraversal(Node node) {
    if (node == null) {
        return;
    }

    // посетить текущий узел
    System.out.print(node.key + " ");

    // рекурсивно обойти левое поддерево
    preOrderTraversal(node.left);

    // рекурсивно обойти правое поддерево
    preOrderTraversal(node.right);
}
```

### Симметричный

Симметричный обход бинарного дерева заключается в том, что сначала посещается левое поддерево, затем текущий узел, и затем правое поддерево.

Алгоритм симметричного обхода:

1. Проверяем, что текущий узел не является пустым.
2. Рекурсивно вызываем симметричный обход для левого поддерева текущего узла.
3. Обрабатываем значение ключа текущего узла.
4. Рекурсивно вызываем симметричный обход для правого поддерева текущего узла.

В результате обхода, узлы дерева будут обработаны **в порядке возрастания ключей**.

```java
public void inOrderTraversal(Node node) {
    if (node == null) {
        return;
    }

    inOrderTraversal(node.left);
    System.out.print(node.value + " ");
    inOrderTraversal(node.right);

}

```

### Обратный

Обратный обход бинарного дерева (инфиксный обход) происходит в следующем порядке: сначала рекурсивно обходим левое поддерево, затем правое поддерево, а затем посещаем текущий узел.

Алгоритм обратного обхода:

1. Если текущий узел равен null, то ничего не делаем и выходим из функции.
2. Рекурсивно обходим левое поддерево.
3. Рекурсивно обходим правое поддерево.
4. Посещаем текущий узел

```java
public void traversePostOrder(Node node) {
    if (node != null) {
        traversePostOrder(node.right); // обход правого поддерева
        traversePostOrder(node.left); // обход левого поддерева
        System.out.print(node.value + " "); // обработка текущего узла
    }
}
```

Этот обход сначала удаляет все листья дерева, затем их родителей и т.д., пока не дойдет до корня дерева.

## Нахождение минимума и максимума

Алгоритм поиска минимума в бинарном дереве поиска:

1. Начинаем обход дерева с корня
2. Если левый потомок существует, переходим к нему
3. Если левый потомок отсутствует, текущий узел является узлом с минимальным значением ключа

```java
public Node findMin(Node node) {
    if (node == null) {
        return null; // если дерево пустое, вернуть null
    }
    while (node.left != null) {
        node = node.left; // идем влево до тех пор, пока не найдем узел без левого потомка
    }
    return node; // возвращаем найденный узел
}
```

Временная сложность:

- Худший случай: O(n)
- Средний случай: O(log n)
