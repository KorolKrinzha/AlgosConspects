# Бинарный поиск - Семинар

## Вспоминаем задачу про копировальные машины

Формула **(t-x/x)+ (t-y/y)+1** образует массив

```
0 1 2 3 4 5 6 7 8 - t время
0 0 0 1 1 2 3 3 4 - копирок копировальная машина

```

Сколько мы можем получить копий за время t, например 6? Ответ найдем с помощью бинпоиска.

**Ответ:** 6 минут

## Задача на поиск пропущенного числа - бинпоиск

Упорядоченная последовательность чисел от 1 до n, в которой одно число пропущено. Найти пропущенное число.

Идея: бинпоиск. Если совпадают индекс и значение, то сдвигаем левую границу вправо, иначе сдвигаем правую границу влево.

## Задача на поиск пропущенного числа - XOR

```
int missingNumber(int[] nums) {
    int missing = nums.length;
    for (int i = 0; i < nums.length; i++) {
        missing ^= i ^ nums[i];
    }
    return missing;
}
```

Объяснение четвертой строки

missing ^= i ^ nums[i];

Оператор XOR (^) используется в сочетании с оператором присваивания (=).

Утверждение можно разбить следующим образом:

1. Переменная missing первоначально устанавливается на длину входного массива nums.
2. Переменная i представляет собой текущий индекс массива по мере выполнения цикла итераций по нему.
3. nums[i] - это значение в текущем индексе массива.
4. missing выполняется XOR с i и nums[i] с помощью оператора XOR (^), а результат присваивается обратно missing с помощью оператора присваивания (=).

Эта строка кода, по сути, выполняет операцию XOR над i и nums[i] и обновляет переменную missing результатом. И это делается для каждого элемента массива.

К концу цикла недостающая переменная будет содержать XOR всех индексов и значений в массиве. Поскольку мы знаем, что недостающее число - это то, которое отсутствует в наборе чисел от 0 до n-1, мы можем использовать свойство XOR, о котором я говорил ранее: если вы XORите любое число с одним и тем же числом дважды, вы получите 0,
и если вы XOR любое число с 0, вы получите то же самое число. Путем операции XOR недостающего числа со всеми остальными числами, недостающее число станет оставшимся в недостающей переменной.

````

## Задача на поиск пропущенного числа - суммирование

Сложим все числа от 1 до n, вычтем сумму элементов массива.
Остаток - пропущенное число.

```java
int missingNumber(int[] nums) {
    int n = nums.length;
    int expectedSum = n * (n + 1) / 2;
    int actualSum = 0;
    for (int num : nums) {
        actualSum += num;
    }
    return expectedSum - actualSum;
}

````

## Задача на поиск пропущенного числа - динаамическое программирование

```java
int missingNumber(int[] nums) {
    int n = nums.length;
    boolean[] present = new boolean[n+1];
    for (int num : nums) {
        present[num] = true;
    }
    for (int i = 1; i <= n; i++) {
        if (!present[i]) {
            return i;
        }
    }
    return -1;
}

```

Алгоритм хуже предыдущих, он требует дополнительной памяти.
Time complexity: O(n) (как в задаче про сумму), Space complexity: O(n).

## Задача на поиск наибольшего возрастающего подмассива

### Создание массива возрастающих подмассивов

[2,6,8,3,4,5,1]
Какими могут быть подмассивы:
[2, 3, 4, 5]
[2,6,8]
[3,4,5]

Рассмотрим решение за O(n^2).
Создадим массив возрастающих подмассивов, где каждый элемент подмассив.
[ [2,6,8], [2,3,4,5], [1]] - 3 подмассива.
Ответ: 4.

### Запоминание максимума

```java
public static int maxIncreasingSubarray(int[] arr) {
    int maxLength = 0;
    for (int i = 0; i < arr.length; i++) {
        int currentLength = 1;
        for (int j = i+1; j < arr.length; j++) {
            if (arr[j] > arr[j-1]) {
                currentLength++;
            } else {
                break;
            }
        }
        maxLength = Math.max(maxLength, currentLength);
    }
    return maxLength;
}

```

Этот подход имеет временную сложность O(n^2), поскольку он включает в себя вложенные циклы: внешний цикл, который итерирует массив, и внутренний цикл, который сравнивает текущий элемент со всеми оставшимися элементами в массиве.

Решение за O(n logn) - бинпоиск

```java
public static int maxIncreasingSubarray(int[] arr) {
    int[] dp = new int[arr.length];
    int len = 0;
    for (int x : arr) {
        int i = Arrays.binarySearch(dp, 0, len, x);
        if (i < 0) {
            i = -(i + 1);
        }
        dp[i] = x;
        if (i == len) {
            len++;
        }
    }
    return len;
}
```
