## 4 способа представить дерево

### 1. Список ребер

Реализация:
ArrayList<ArrayList<Integer>>

[[ui,vi]]

- Поиск исходящих и входящих ребер O(|E|)
- Хранение O(|E|)
- Просмотр наличия ребра O(|E|)

### 2. Список смежности

HashMap<ArrayList<Integer>>

v1: [u1, u2, ...], v2: [u5, u7, ...],

- Проверка наличия ребра у вершины O(1)
- Память O(|v|\*|E|)
- Есть ли ребро из вершины в вершину O(E)

### 3. Матрица смежности

ArrayList<ArrayList<Integer>>

Матрица |u| |v|, ставим 0 (нет соединения) или 1 (есть соединение) для невзвешанных графов или весы и -1
(или другое любое спец значение для отсутствующих соединений)

- Память O(|v2|)

### 4. Представление через классы как связные списки

public class Node<T> {
public T value;
public Node<T> neighbors[];
}

- Добавление/Удаление O(1)
- Индексация O(|V|\*|E|)

## DFS: Depth-first search

Поиск в глубину - один из методов обхода графа

Два метода написать DFS:

- стэк
- рекурсия

Алгоритм рекурсией. Выполняется для связного графа

```java
boolean visited []; // массив показывает, посетили ли мы вершину или нет
public void DFS(Node node){
    // операция t in выполняется здесь
    visited [node.number] = true; // посещенную вершину помечаем как true

    // цикл для всех соседей
    for (int i = 0; i = Node.neighbors.length; i++){
        // если не посещен, то запускаем dfs
        if (!visited[Node.neighbors[i]]){
            dfs(Node.neighbors[i])
        }
    }
    // операция t out выполняется здесь
}
```

Запускаем в корне. Корень в ориентированном графе - вершина без потомков

```
      1
   /    \
  2      3
 / \ \  / \
4   5 6 7  8
    /\
   9  10
```

1 - корень

Обход dfs:
[1,2,4,5,9,10,6,3,7,8]

Алгоритм стэка.

```java
public void DFS (HashMap<ArrayList<Integer>> adj){
    // adj - список смежности
    Stack stack = new Stack;
    boolean visited = new boolean[adj.length]; //
    stack.push(0);
    while (!stack.isEmpty()){
        int v = stack.pop();
        if (!visited[v]){
            visited[v] = true;
            for (int i=0; i<adj[v].length;i++){
                stack.push(adj[v][i])
            }
        }
    }
}
```

Рассмотрим на том же примере

```

     1
  /     \
 2      3
/ \ \  / \
4 5 6  7 8
/ \ \
9 10 12

```

```
stack:

1. [1]
2. [2, 3]
3. [2, 7, 8]
4. [2, 7, 12]
5. [2, 7]
6. [2]
7. [4, 5, 6]
8. [4, 5]
9. [4, 9, 10]
10. [4, 9]
11. [4, 10]
12. [4]
13. []

visited

1. []
2. [1]
3. [1,3]
4. [1,3,8]
5. [1,3,8, 12]
6. [1,3,8, 12, 7]
7. [1,3,8, 12, 7, 2]
8. [1,3,8, 12, 7, 2, 6]
9. [1,3,8, 12, 7, 2, 6, 5]
10. [1,3,8, 12, 7, 2, 6, 5, 9]
11. [1,3,8, 12, 7, 2, 6, 5, 9, 10]
12. [1,3,8, 12, 7, 2, 6, 5, 9, 10, 4]


```

## BFS Breadth-First Search

Поиск в ширину — один из методов обхода графа

## Рассмотрим разницу между BFS и DFS

Обход в ширину старается пройти по уровню удаления от начальной вершины - сначала на один уровень, потом на два, и т.д.

Обход в глубину - "углубляемся" в граф, в самый конец

```
DFS обычно применяется в следующих задачах:

- Поиска кратчайшего пути
- Поиск циклов
- Компоненты связности
- Поиск мостов и точек сочленения

BFS чаще всего используется в следующих задачах:

- Кратчайший путь в невзвешенном графе
- Нахождение минимального количества шагов для достижения цели (например, в играх сетки)
- Нахождение диаметра графа (максимального расстояния между двумя вершинами)
- Поиск компонент связности
- Поиск пути с минимальным числом ребер
```

## Топологическая сортировка графов

Рассматриваем графы Ориентированные и Ациклические

Источник s и сток t рассматриваемого графа.

Топологическая сортировка - способ нумерации вершин ориентированного графа, при котором каждое ребро ведёт из вершины с меньшим номером в вершину с большим номером.
