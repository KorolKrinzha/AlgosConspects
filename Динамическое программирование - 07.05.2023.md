# Динамическое программирование

## Определение

Динамическое программирование (Dynamic Programming) — это метод решения задач, основанный на **разбиении исходной задачи на более мелкие подзадачи**, решение каждой из которых производится только один раз, после чего результаты **сохраняются для дальнейшего использования** при решении большей задачи.

## Применение

Динамическое программирование часто используется для задач оптимизации, например, нахождения минимального пути или наибольшей подпоследовательности.

## Задача про кузнечика

Задача про кузнечика — это стандартный пример задачи, которая решается с помощью динамического программирования.

**Задача:** найти количество способов, которыми кузнечик может добраться из точки 1 до точки N, прыгая только на 1 или 2 шага вперед.

**Решение:** Создадим массив dp размером N+1, где dp[i] будет хранить количество способов, которыми кузнечик может добраться из точки 1 до точки i.

dp[0] равна нулю, начальные значения dp[1] и dp[2] будут равны 1 и 2 соответственно - в первую он может прыгнуть только одним прыжком, во вторую с помощью двух одинарных прыжков и с помощью одного двойного

Затем мы будем заполнять массив dp с помощью цикла от 3 до N. Для каждого i мы будем находить сумму dp[i-1] и dp[i-2], так как кузнечик может добраться до точки i из точки i-1 или i-2. Таким образом, dp[i] будет равно количеству способов, которыми кузнечик может добраться до точки i.

В конце мы вернем значение dp[N], которое будет равно количеству способов, которыми кузнечик может добраться из точки 1 до точки N.

```java
public int countWays(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

**Временная сложность** данного алгоритма составляет O(n), так как мы выполняем один проход от 3 до n

## Задача про острова

Задача про острова - это классическая задача динамического программирования

Задача: найти максимальное количество островов, которые можно построить на двухмерном поле, имеющем различные типы клеток, такие как земля, вода и т.д.

Алгоритм задачи:

1. Создаем двумерный массив размером n x m, где n - это количество строк, а m - количество столбцов поля.
2. Инициализируем первую строку и первый столбец массива. Если текущая клетка поля - земля, то значение массива равно 1, иначе 0.
3. Для каждой клетки поля с координатами (i, j) проверяем ее тип:

- Если клетка - земля, то значение ячейки dp[i][j] равно сумме значений двух предыдущих клеток: dp[i-1][j] и dp[i][j-1].
- Если клетка - вода, то значение равно 0.

4. После обхода всего поля максимальное количество островов будет находиться в ячейке dp[n-1][m-1].

```java
public class Island {

    public static int countIslands(int[][] matrix) {
        int count = 0;
        int n = matrix.length;
        int m = matrix[0].length;
        boolean[][] visited = new boolean[n][m];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 1 && !visited[i][j]) {
                    // Нашли не посещенную клетку с островом
                    count++;
                    visitIsland(matrix, visited, i, j);
                }
            }
        }
        return count;
    }

    private static void visitIsland(int[][] matrix, boolean[][] visited, int row, int col) {
        int n = matrix.length;
        int m = matrix[0].length;
        // Проверяем, что клетка внутри матрицы и является частью острова
        if (row < 0 || row >= n || col < 0 || col >= m || matrix[row][col] == 0 || visited[row][col]) {
            return;
        }
        // Помечаем клетку как посещенную
        visited[row][col] = true;
        // Посещаем соседние клетки
        visitIsland(matrix, visited, row - 1, col); // вверх
        visitIsland(matrix, visited, row + 1, col); // вниз
        visitIsland(matrix, visited, row, col - 1); // влево
        visitIsland(matrix, visited, row, col + 1); // вправо
    }

    public static void main(String[] args) {
        int[][] matrix = {
                {1, 1, 0, 0, 0},
                {1, 1, 0, 0, 0},
                {0, 0, 1, 0, 0},
                {0, 0, 0, 1, 1}
        };
        System.out.println("Number of islands: " + countIslands(matrix));
    }
}
```
