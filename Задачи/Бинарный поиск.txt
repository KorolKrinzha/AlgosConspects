
# Задачи на бинпоиск

##  Longest Increasing Subsequence

Given an integer array nums, return the length of the longest strictly increasing 
subsequence

Идея: рассмотрим на примере 
0. [2, 6, 8, 3, 4, 5, 1]
1. Построим первую подпоследовательность, которая будет строго возрастающей: 
[2, 6, 8]
2. Встретили тройку, она не войдет в подпоследовательность. 
3. Запишем тройку в другую строго возрастающую подпоследовательность, она тоже начинается с двух:
[2,3]
4. Встретили четверку, она не войдет в подпоследовательность 1, но войдет в подпоследовательность два.
 - [2,6,8]
 - [2,3,4]
5. Встретили пятерку
    - [2,6,8]
    - [2,3,4,5]
6. Встретили единицу, она не войдет ни в одну подпоследовательность, но войдет в новую строго возрастающую подпоследовательность:
 - [2,6,8]
 - [2,3,4,5]
 - [1]
7. В итоге получили 3 строго возрастающие подпоследовательности, длина максимального равна 4.

Но в этом решении мы держим целых три подмассива. 
Как насчет вместо создания подмассива из нового элемента мы просто будем их сравнивать и вставлять в нужное место?

0. [2, 6, 8, 3, 4, 5, 1]
1. [2,6,8]
3. Тройка меньше восьмерки, ее нужно куда-то пристроить с помощью бинпоиска: [2,3,8]
4. Четверка меньше восьмерки, ее нужно куда-то пристроить с помощью бинпоиска: [2,3,4]
5. Пятерка при добавлении образует возрастающую последовательность, добавляем ее: [2,3,4,5]
6. Единица меньше пятерки, ее нужно куда-то пристроить с помощью бинпоиска: [1,3,4,5]
7. В итоге получили 4 строго возрастающие подпоследовательности, длина максимального равна 4.

```python
class Solution:  # 68 ms, faster than 93.92%
    def lengthOfLIS(self, nums: List[int]) -> int:
        sub = []
        for x in nums:
            if len(sub) == 0 or sub[-1] < x:
                sub.append(x)
            else:
                idx = bisect_left(sub, x)  # Find the index of the first element >= x
                sub[idx] = x  # Replace that number with x
        return len(sub)
```

## Найти верхний экстремум в массиве

A peak element is an element that is strictly greater than its neighbors.
Given a 0-indexed integer array nums, find a peak element, and return its index.
If the array contains multiple peaks, return the index to any of the peaks.

Идея:
Мы можем рассматривать любую заданную последовательность в массиве nums
как чередующиеся восходящие и нисходящие последовательности.
Используя это, а также тот факт, что мы можем вернуть любую вершину в качестве результата,
мы можем использовать бинарный поиск для нахождения требуемого элемента вершины.

В случае простого двоичного поиска мы работаем с отсортированной последовательностью
и пытаемся найти требуемое число, уменьшая пространство поиска на каждом шаге.
В данном случае мы используем модификацию простого двоичного поиска в наших интересах.
Мы начинаем с поиска среднего элемента, mid, из заданного массива nums. 
Если окажется, что этот элемент лежит в убывающей последовательности 
чисел или имеет локальный падающий наклон (найденный путем сравнения nums с его правым соседом),
это означает, что вершина всегда будет лежать слева от этого элемента.
Таким образом, мы уменьшаем пространство поиска слева от mid (включая его самого)
и выполняем тот же процесс в левом подмассиве.

Если средний элемент, mid, лежит в возрастающей последовательности чисел 
или имеет восходящий наклон (найденный путем сравнения nums[i] с его правым соседом),
то очевидно, что пик лежит справа от этого элемента.
Таким образом, мы уменьшаем пространство поиска справа от середины 
и выполняем тот же процесс в правом подмассиве.

Таким образом, мы продолжаем уменьшать пространство поиска,
пока в конце концов не достигнем состояния, 
когда в пространстве поиска останется только один элемент.
Этот единственный элемент и есть пиковый элемент.

Рассмотрим примеры:
Пример 1:
0. nums = [1,2,3,4,5] 
1. Начинаем с середины - 3. Справа возрастает, сокращаем пространство поиска до [4,5]
2. Начинаем с середины - 4. Справа возрастает, сокращаем пространство поиска до [5]
3. 5 - пик

Пример 2:
0. nums = [1,2,3,5,1]
1. Начинаем с середины - 3. Справа возрастает, сокращаем пространство поиска до [5,1]
2. Начинаем с середины - 5. Справа убывает
3. 5 - пик

```java
public class Solution {
    public int findPeakElement(int[] nums) {
        return search(nums, 0, nums.length - 1);
    }
    public int search(int[] nums, int l, int r) {
        if (l == r)
            return l;
        int mid = (l + r) / 2;
        if (nums[mid] > nums[mid + 1])
            return search(nums, l, mid);
        return search(nums, mid + 1, r);
    }
}
```
Сложность: O(logN)

## Поиск пропавшего элемента

Найти пропущенное число на промежутке 0-N в массиве чисел размера N

```java
class Solution {
    public int missingNumber(int[] nums) {
        Arrays.sort(nums); 
        int left = 0, right = nums.length, mid = (left + right) / 2;
        while (left < right) {
            mid = (left + right) / 2;
            if (nums[mid] > mid)
                right = mid;
            else
                left = mid + 1;
        }
        return left;

    }
}
```

Сложность: O(logN)   