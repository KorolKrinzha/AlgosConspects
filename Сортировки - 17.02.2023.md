# Сортировки - Лекция

## Слияние сортированных массивов

### Слияние 2ух сортированных массивов

0. Дано [1,2,4,6,8] [3,4,10,15,21,23,27]
1. Создаем массив длиной 5+7=12 элементов
2. Два указателя, каждый на первый элемент массива
3. Сравниваем элементы на указатели, берем меньший и записываем в новый массив
4. Двигаем указатель на следующий элемент в массиве, из которого мы взяли элемент
5. Повторяем пункты 2-3, пока не закончатся элементы во всех массивах

Сложность: O(n)

### Слияние k сортированных массивов

0. Дано [f1, ....], [s1, ...], [t1, ...]
1. Воспользуемся кучей для минимума.
2. Строим минимальную кучу из первых элементов каждого массива.
3. Берем минимальный элемент из кучи, записываем его в начало нового массива.

```
     f2
    / \
   f3   f5
  / \ /   \
 t6  s1 s5 s2
            \
            ...
```

4. Добавляем в кучу следующий элемент из массива, из которого мы взяли элемент.
   Это делается при помощи siftDown.
5. Повторяем пункты 3-4, пока не закончатся элементы в одном из массивов

Конкретный пример

1. [1,4,5,9] [2,5,7,15] [1,2,6] [3,4,6]
2. Строим кучу из первых элементов каждого массива

```
     1
    / \
   2   1
  /
 3
```

3. Берем минимальный элемент из кучи, записываем его в начало нового массива.
4. Применяем siftDown к куче

```
     1
    / \
   3   2

```

5. Добавляем в кучу следующий элемент из массива, из которого мы взяли элемент. Это будет 4
   Применяем siftUp

```
     1
    / \
   3   2
  /
 4
```

6. Применяем siftDown

```
     2
    / \
   3   4
```

7.

```
     2
    / \
   2   4
  /
 3
```

8. Наш отсортированный массив сейчас выглядит так [1,1,2,]

## Сортировка слиянием

Идея: делаем рекурсивное слияние его половинок

Пример:

0. [15,8,1,3,7,4,20,2,5]
1. [15,8,1,3] [7,4,20,2,5]
2. [15,8] [1,3] [7,4] [20,2,5]
3. [15] [8] [1] [3] [7] [4] [20] [2, 5]
4. [15] [8] [1] [3] [7] [4] [20] [2] [5]
5. Сливаем

- [15] [8]: [8,15]
- [1] [3]: [1,3]
- [7] [4]: [4,7]
- [20] [2] [5]: [2,5,20]

6. Сливаем

- [8,15] [1,3]: [1,3,8,15]
- [4,7] [2,5,20]: [2,4,5,7,20]

7. Сливаем

- [1,3,8,15] [2,4,5,7,20]: [1,2,3,4,5,7,8,15,20]

8. Массив отсортирован

Сложность: O(nlogn)

- logn раз делаем слияние (каждый раз массив делится на 2 части)
- каждое слияние занимает O(n) времени

## Мастер-теорема

Мастер теорема (Master Theorem) - это метод для определения
асимптотической сложности рекурсивных алгоритмов,
основанный на методе divide and conquer.

Формула для вычисления сложности алгоритма:

```
T(n) = aT(n/b) + f(n),
```

- T(n) - сложность алгоритма для входных данных размера n
- a - количество подзадач, которые необходимо решить
- b - масштабирование размера входных данных в каждой подзадаче
  (обычно b = 2 для алгоритмов, использующих разделение и завоевание)
- f(n) - сложность разделения, объединения и любых других операций,
  которые не относятся к рекурсивному вызову.

## Амортизационный анализ

Амортизационный анализ - это метод анализа алгоритмов, который позволяет оценить среднюю сложность

Этот метод позволяет оценить сложность алгоритма,
даже если некоторые операции занимают значительно больше времени, чем другие.

Амортизационный анализ используется в случаях,
когда алгоритм включает в себя операции с переменной временной сложностью,
и позволяет оценить среднее время выполнения этих операций на основе общего времени выполнения

Пример:

0. Дан динамический массив [x,x,x,x] и операции push_back, pop_back, index
1. push_back(1) - [x,x,x,x,1,0,0,0]. Операция выполняется за O(n), так как мы копируем все n элементов в новый массив
2. push_back(2) - [x,x,x,x,1,2,0,0]. Операция выполняется за O(1), так как мы просто добавляем элемент в конец массива

Мы же не можем сказать, что push_back выполняется за O(n), так как в среднем он выполняется за O(1)

Для этого мы используем амортизационный анализ. В среднем push_back выполняется за O(1).
Это есть его амортизационная сложность.

Амортизированная сложность - это средняя сложность операции

## Как считать амортизационную сложность?

### Метод предоплаты (метод бухчета)

Суть метода заключается в том, что перед выполнением каждой операции алгоритма,
мы предварительно выплачиваем "предоплату" (prepayment),
то есть переплачиваем за эту операцию, чтобы компенсировать будущие операции.
Эти переплаты затем используются для оценки средней стоимости операций.
